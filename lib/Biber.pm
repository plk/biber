package Biber;
use strict;
use warnings;
use Carp;
use Encode;
use File::Copy;
use File::Spec;
use IO::File;
use IPC::Cmd qw( can_run run );
use POSIX qw( locale_h ); # for sorting with built-in "sort"
use Cwd qw( abs_path );
use Biber::Config;
use Biber::Constants;
use List::Util qw( first );
use Digest::MD5 qw( md5_hex );
use Biber::Internals;
use Biber::Entries;
use Biber::Entry;
use Biber::Entry::Name;
use Biber::Sections;
use Biber::Section;
use Biber::Structure;
use Biber::Utils;
use Storable qw( dclone );
use Log::Log4perl qw( :no_extra_logdie_message );
use base 'Biber::Internals';
use Config::General qw( ParseConfig );
use Data::Dump;
use Text::BibTeX; # Need this in here in order to reset @STRING macros per section
our @ISA;

=encoding utf-8

=head1 NAME

Biber - main module for biber, a bibtex replacement for users of biblatex

=cut

our $VERSION = '0.7.3';
our $BETA_VERSION = 1; # Is this a beta version?

=head1 SYNOPSIS

    use Biber;

    my $biber = Biber->new();
    $biber->parse_ctrlfile("example.bcf");
    $biber->prepare;

=cut

my $logger = Log::Log4perl::get_logger('main');

=head1 METHODS

=head2 new

    Initialize the Biber object, optionally passing named options as arguments.

=cut

sub new {
  my ($class, %opts) = @_;
  my $self = bless {}, $class;

  # Set up config object from config file and defaults
  if (defined $opts{configfile}) {
    Biber::Config->_initopts( $opts{configfile} );
  } else {
    Biber::Config->_initopts(undef, $opts{noconf});
  }
  # Command-line overrides everything else
  if (%opts) {
    foreach (keys %opts) {
      Biber::Config->setcmdlineoption($_, $opts{$_});
    }
  }
  return $self;
}

=head2 biber_warn

    Wrapper around various warnings bits and pieces
    Logs a warning, increments warning count in Biber object and add warning to
    the list of .bbl warnings to add

=cut

sub biber_warn {
  my $self = shift;
  my $entry = shift;
  my $warning = shift;
  $logger->warn($warning);
  $entry->add_warning($warning);
  $self->{warnings}++;
  return;
}


=head2 sections

    my $sections= $biber->sections

    Returns a Biber::Sections object describing the bibliography sections

=cut

sub sections {
  my $self = shift;
  return $self->{sections};
}


=head2 set_output_obj

    Sets the object used to output final results
    Must be a subclass of Biber::Output::Base

=cut

sub set_output_obj {
  my $self = shift;
  my $obj = shift;
  croak('Output object must be subclass of Biber::Output::Base!') unless $obj->isa('Biber::Output::Base');
  $self->{output_obj} = $obj;
  return;
}


=head2 get_preamble

    Returns the current preamble as an array ref

=cut

sub get_preamble {
  my $self = shift;
  return $self->{preamble};
}


=head2 get_output_obj

    Returns the object used to output final results

=cut

sub get_output_obj {
  my $self = shift;
  return $self->{output_obj};
}

=head2 set_current_section

    Sets the current section number that we are working on to a section number

=cut

sub set_current_section {
  my $self = shift;
  my $secnum = shift;
  $self->{current_section} = $secnum;
  return;
}

=head2 get_current_section

    Gets the current section number that we are working on

=cut

sub get_current_section {
  my $self = shift;
  return $self->{current_section};
}

=head2 parse_ctrlfile

    This method reads the control file
    generated by biblatex to work out the various biblatex options.
    See Constants.pm for defaults and example of the data structure being built here.

=cut

sub parse_ctrlfile {
  my ($self, $ctrl_file) = @_;

  $logger->logcroak("Cannot find control file '$ctrl_file'! - did you pass the \"backend=biber\" option to BibLaTeX?") unless -f "$ctrl_file";

  # Validate if asked to
  if (Biber::Config->getoption('validate_control')) {
    require XML::LibXML;

    # Set up XML parser
    my $CFxmlparser = XML::LibXML->new();
    $CFxmlparser->line_numbers(1); # line numbers for more informative errors

    # Set up schema
    my $CFxmlschema;

    # we assume that the schema files are in the same dir as Biber.pm:
    (undef, my $biber_path, undef) = File::Spec->splitpath( $INC{"Biber.pm"} );

    # Deal with the strange world of Par::Packer paths
    # We might be running inside a PAR executable and @INC is a bit odd in this case
    # Specifically, "Biber.pm" in @INC might resolve to an internal jumbled name
    # nowhere near to these files. You know what I mean if you've dealt with pp
    my $bcf_rng;
    if ($biber_path =~ m|/par\-| and $biber_path !~ m|/inc|) { # a mangled PAR @INC path
      $bcf_rng = File::Spec->catfile($biber_path, 'inc', 'lib', 'Biber', 'bcf.rng');
    }
    else {
      $bcf_rng = File::Spec->catfile($biber_path, 'Biber', 'bcf.rng');
    }

    if (-e $bcf_rng) {
      $CFxmlschema = XML::LibXML::RelaxNG->new( location => $bcf_rng )
    }
    else {
      $logger->warn("Cannot find XML::LibXML::RelaxNG schema. Skipping validation : $!");
      $self->{warnings}++;
      goto CONVERT;
    }

    # Parse file
    my $CFxp = $CFxmlparser->parse_file("$ctrl_file");

    # XPath context
    my $CFxpc = XML::LibXML::XPathContext->new($CFxp);
    $CFxpc->registerNs('bcf', 'https://sourceforge.net/projects/biblatex');

    # Validate against schema. Dies if it fails.
    if ($CFxmlschema) {
      eval { $CFxmlschema->validate($CFxp) };
      if (ref($@)) {
        $logger->debug( $@->dump() );
        $logger->logcroak("BibLaTeX control file \"$ctrl_file\" failed to validate\n$@");
      }
      elsif ($@) {
        $logger->logcroak("BibLaTeX control file \"$ctrl_file\" failed to validate\n$@");
      }
      else {
        $logger->info("BibLaTeX control file \"$ctrl_file\" validates");
      }
    }
    undef $CFxmlparser;
  }

  # Convert .bcf to .html using XSLT transform if asked to
 CONVERT:
  if (Biber::Config->getoption('convert_control')) {

    require XML::LibXSLT;
    require XML::LibXML;

    my $xslt = XML::LibXSLT->new();
    my $CFstyle;

    # we assume that the schema files are in the same dir as Biber.pm:
    (undef, my $biber_path, undef) = File::Spec->splitpath( $INC{"Biber.pm"} );

    # Deal with the strange world of Par::Packer paths
    # We might be running inside a PAR executable and @INC is a bit odd in this case
    # Specifically, "Biber.pm" in @INC might resolve to an internal jumbled name
    # nowhere near to these files. You know what I mean if you've dealt with pp
    my $bcf_xsl;
    if ($biber_path =~ m|/par\-| and $biber_path !~ m|/inc|) { # a mangled PAR @INC path
      $bcf_xsl = File::Spec->catfile($biber_path, 'inc', 'lib', 'Biber', 'bcf.xsl');
    }
    else {
      $bcf_xsl = File::Spec->catfile($biber_path, 'Biber', 'bcf.xsl');
    }

    if (-e $bcf_xsl) {
      $CFstyle = XML::LibXML->load_xml( location => $bcf_xsl, no_cdata=>1 )
    }
    else {
      $logger->warn("Cannot find XML::LibXSLT stylesheet. Skipping conversion : $!");
      $self->{warnings}++;
      goto LOADCF;
    }

    my $CF = XML::LibXML->load_xml(location => $ctrl_file);
    my $stylesheet = $xslt->parse_stylesheet($CFstyle);
    my $CFhtml = $stylesheet->transform($CF);
    $stylesheet->output_file($CFhtml, $ctrl_file . '.html');
    $logger->info("Converted BibLaTeX control file '$ctrl_file' to '$ctrl_file.html'");
  }

  # Open control file
 LOADCF:
  my $ctrl = new IO::File "<$ctrl_file"
    or $logger->logcroak("Cannot open $ctrl_file: $!");

  $logger->info("Reading $ctrl_file");

  # Read control file
  require XML::LibXML::Simple;

  my $bcfxml = XML::LibXML::Simple::XMLin($ctrl,
                                          'ForceContent' => 1,
                                          'ForceArray' => [
                                                           qr/\Acitekey\z/,
                                                           qr/\Aoption\z/,
                                                           qr/\Aoptions\z/,
                                                           qr/\Avalue\z/,
                                                           qr/\Asortitem\z/,
                                                           qr/\Abibdata\z/,
                                                           qr/\Adatasource\z/,
                                                           qr/\Asection\z/,
                                                           qr/\Asortexclusion\z/,
                                                           qr/\Aexclusion\z/,
                                                           qr/\Asort\z/,
                                                           qr/\Apresort\z/,
                                                           qr/\Atype_pair\z/,
                                                           qr/\Ainherit\z/,
                                                           qr/\Afieldor\z/,
                                                           qr/\Afieldxor\z/,
                                                           qr/\Afield\z/,
                                                           qr/\Aalias\z/,
                                                           qr/\Aconstraints\z/,
                                                           qr/\Aconstraint\z/,
                                                           qr/\Aentrytype\z/,
                                                          ],
                                          'NsStrip' => 1,
                                          'KeyAttr' => []);

  my $controlversion = $bcfxml->{version};
  Biber::Config->setblxoption('controlversion', $controlversion);
  $logger->warn("Warning: Found biblatex control file version $controlversion, expected version $BIBLATEX_VERSION")
    unless $controlversion eq $BIBLATEX_VERSION;

  # Look at control file and populate our main data structure with its information

  # OPTIONS
  foreach my $bcfopts (@{$bcfxml->{options}}) {

    # Biber options
    if (lc($bcfopts->{component}) eq 'biber') {

      # Global options
      if (lc($bcfopts->{type}) eq 'global') {
        foreach my $bcfopt (@{$bcfopts->{option}}) {
          unless (defined(Biber::Config->getcmdlineoption($bcfopt->{key}{content}))) { # already set on cmd line
            if (lc($bcfopt->{type}) eq 'singlevalued') {
              Biber::Config->setoption($bcfopt->{key}{content}, $bcfopt->{value}[0]{content});
            }
            elsif (lc($bcfopt->{type}) eq 'multivalued') {
              Biber::Config->setoption($bcfopt->{key}{content},
                [ map {$_->{content}} sort {$a->{order} <=> $b->{order}} @{$bcfopt->{value}} ]);
            }
          }
        }
      }
    }

    # BibLaTeX options
    if (lc($bcfopts->{component}) eq 'biblatex') {

      # Global options
      if (lc($bcfopts->{type}) eq 'global') {
        foreach my $bcfopt (@{$bcfopts->{option}}) {
          if (lc($bcfopt->{type}) eq 'singlevalued') {
            Biber::Config->setblxoption($bcfopt->{key}{content}, $bcfopt->{value}[0]{content});
          } elsif (lc($bcfopt->{type}) eq 'multivalued') {
            Biber::Config->setblxoption($bcfopt->{key}{content},
              [ map {$_->{content}} sort {$a->{order} <=> $b->{order}} @{$bcfopt->{value}} ]);
          }
        }
      }

      # Entrytype options
      else {
        my $entrytype = $bcfopts->{type};
        foreach my $bcfopt (@{$bcfopts->{option}}) {
          if (lc($bcfopt->{type}) eq 'singlevalued') {
            Biber::Config->setblxoption($bcfopt->{key}{content}, $bcfopt->{value}[0]{content}, 'PER_TYPE', $entrytype);
          } elsif (lc($bcfopt->{type}) eq 'multivalued') {
            Biber::Config->setblxoption($bcfopt->{key}{content},
              [ map {$_->{content}} sort {$a->{order} <=> $b->{order}} @{$bcfopt->{value}} ],
              'PER_TYPE',
              $entrytype);
          }
        }
      }
    }
  }

  # INHERITANCE schemes for crossreferences (always global)
  # This should not be optional any more when biblatex implements this so take
  # out this conditional
  if (exists($bcfxml->{inheritance})) {
    Biber::Config->setblxoption('inheritance', $bcfxml->{inheritance});
  }

  # SORTING

  # sorting excludes
  foreach my $sex (@{$bcfxml->{sorting}{sortexclusion}}) {
    my $excludes;
    foreach my $ex (@{$sex->{exclusion}}) {
      $excludes->{$ex->{content}} = 1;
    }
    Biber::Config->setblxoption('sortexclusion',
                                $excludes,
                                'PER_TYPE',
                                $sex->{type});
  }

  # presort defaults
  foreach my $presort (@{$bcfxml->{sorting}{presort}}) {
    # Global presort default
    unless (exists($presort->{type})) {
      Biber::Config->setblxoption('presort', $presort->{content});
    }
    # Per-type default
    else {
      Biber::Config->setblxoption('presort',
                                  $presort->{content},
                                  'PER_TYPE',
                                  $presort->{type});
    }
  }

  my $sorting_label = [];
  my $sorting_final = [];
  foreach my $sort (sort {$a->{order} <=> $b->{order}} @{$bcfxml->{sorting}{sort}}) {
    my $sortingitems_label;
    my $sortingitems_final;

    # Determine which sorting pass(es) to include the item in
    my $whichpass = ($sort->{pass} or 'both');

    # Generate sorting pass structures
    foreach my $sortitem (sort {$a->{order} <=> $b->{order}} @{$sort->{sortitem}}) {
      my $sortitemattributes = {};
      if (defined($sortitem->{substring_side})) { # Found sorting substring side attribute
        $sortitemattributes->{substring_side} = $sortitem->{substring_side};
      }
      if (defined($sortitem->{substring_width})) { # Found sorting substring length attribute
        $sortitemattributes->{substring_width} = $sortitem->{substring_width};
      }
      if (defined($sortitem->{pad_width})) { # Found sorting pad length attribute
        $sortitemattributes->{pad_width} = $sortitem->{pad_width};
      }
      if (defined($sortitem->{pad_char})) { # Found sorting pad char attribute
        $sortitemattributes->{pad_char} = $sortitem->{pad_char};
      }
      if (defined($sortitem->{pad_side})) { # Found sorting pad side attribute
        $sortitemattributes->{pad_side} = $sortitem->{pad_side};
      }

      # No pass specified, sortitem is included in both sort passes
      # Note that we're cloning the sortitemattributes object so as not to have pointers
      # from one structure to the other
      if (lc($whichpass) eq 'both') {
        push @{$sortingitems_label}, {$sortitem->{content} => $sortitemattributes};
        push @{$sortingitems_final}, {$sortitem->{content} => dclone($sortitemattributes)};
      }

      # "label" specified, sortitem is included only on "label" sort pass
      elsif (lc($whichpass) eq 'label') {
        push @{$sortingitems_label}, {$sortitem->{content} => $sortitemattributes};
      }

      # "final" specified, sortitem is included only on "final" sort pass
      elsif (lc($whichpass) eq 'final') {
        push @{$sortingitems_final}, {$sortitem->{content} => $sortitemattributes};
      }
    }

    # Only push a sortitem if defined. If the item has a conditional "pass"
    # attribute, it may be ommitted in which case we don't want an empty array ref
    # pushing
    # Also, we only push the sort attributes if there are any sortitems otherwise
    # we end up with a blank sort
    my $sopts;
    $sopts->{final}          = $sort->{final}          if defined($sort->{final});
    $sopts->{sort_direction} = $sort->{sort_direction} if defined($sort->{sort_direction});
    $sopts->{sortcase}       = $sort->{sortcase}       if defined($sort->{sortcase});
    $sopts->{sortupper}      = $sort->{sortupper}      if defined($sort->{sortupper});
    if (defined($sortingitems_label)) {
      unshift @{$sortingitems_label}, $sopts;
      push @{$sorting_label}, $sortingitems_label;
    }
    if (defined($sortingitems_final)) {
      unshift @{$sortingitems_final}, $sopts;
      push @{$sorting_final}, $sortingitems_final;
    }
  }
  Biber::Config->setblxoption('sorting', {label => $sorting_label,
                                          final => $sorting_final});

  # STRUCTURE schema (always global)
  # This should not be optional any more when biblatex implements this so take
  # out this conditional
  if (exists($bcfxml->{structure})) {
    Biber::Config->setblxoption('structure', $bcfxml->{structure});
  }

  # SECTIONS
  # This is also where we set data files as these are associated with a bib section

  # Datafiles
  my %bibdatafiles = ();
  foreach my $data (@{$bcfxml->{bibdata}}) {
    foreach my $datasource (@{$data->{datasource}}) {
      # default datatype is bibtex
      my $datatype = $datasource->{datatype} ? $datasource->{datatype} : 'bibtex';
      # file data sources
      if ($datasource->{type} eq 'file') {
        push @{$bibdatafiles{$data->{section}[0]}}, { name     => $datasource->{content},
                                                      datatype => $datatype };
      }
    }
  }

  unless (%bibdatafiles or Biber::Config->getoption('bibdata')) {
    $logger->logcroak("No data files on command line or provided in the file '$ctrl_file'! Exiting")
  }

  my $key_flag = 0;
  my $bib_sections = new Biber::Sections;

SECTION: foreach my $section (@{$bcfxml->{section}}) {
    my $bib_section;

    # Can be multiple section 0 entries and so re-use that section object if it exists
    if (my $existing_section = $bib_sections->get_section($section->{number})) {
      $bib_section = $existing_section;
    }
    else {
      $bib_section = new Biber::Section('number' => $section->{number});
    }

    # Set the data files for the section unless we've already done so
    # (for example, for multiple section 0 entries)
    $bib_section->set_datafiles($bibdatafiles{$section->{number}}) unless
      $bib_section->get_datafiles;

    # Stop reading citekeys if we encounter "*" as a citation as this means
    # "all keys"
    my @keys = ();
    foreach my $keyc (@{$section->{citekey}}) {
      my $key = $keyc->{content};
      if ($key eq '*') {
        $bib_section->allkeys;
        $key_flag = 1; # There is at least one key, used for error reporting below
        $logger->info("Using all citekeys in bib section " . $section->{number});
        $bib_sections->add_section($bib_section);
        next SECTION;
      }
      elsif (not Biber::Config->get_seenkey($key, $section->{number})) {
        # Dynamic set definition
        # Save dynamic key -> member keys mapping for set entry auto creation later
        if (exists($keyc->{type}) and $keyc->{type} eq 'set') {
          $bib_section->set_dynamic_set($key, split /\s*,\s*/, $keyc->{members});
        }
        push @keys, $key;
        $key_flag = 1; # There is at least one key, used for error reporting below
        Biber::Config->incr_seenkey($key, $section->{number});
      }
      elsif (Biber::Config->get_keycase($key) ne $key) {
        $logger->warn("Case mismatch error between cite keys '$key' and '" . Biber::Config->get_keycase($key) . "'");
        $self->{warnings}++;
        next;
      }
    }

    unless ($bib_section->is_allkeys) {
      $logger->info("Found ", $#keys+1 , " citekeys in bib section " . $section->{number})
    }

    if (Biber::Config->getoption('debug')) {
      my @debug_keys = sort @keys;
      unless ($bib_section->is_allkeys) {
        $logger->debug("The citekeys for section " . $section->{number} . " are:\n", "@debug_keys", "\n");
      }
    }
    $bib_section->add_citekeys(@keys);
    $bib_sections->add_section($bib_section);
  }

  # Die if there are no citations in any section
  unless ($key_flag) {
    $logger->warn("The file '$ctrl_file' does not contain any citations!");
    $self->{warnings}++;
  }

  # Add the Biber::Sections object to the Biber object
  $self->{sections} = $bib_sections;

  # Normalise any UTF-8 encoding string immediately to exactly what we want
  # We want the strict perl utf8 "UTF-8"
  normalise_utf8();

  return;
}

#=====================================================
# Parse BIB file
#=====================================================

=head2 parse_bibtex

    This is a wrapper method to parse a bibtex database. It
    passes the job to Text::BibTeX via Biber::Input::BibTeX

=cut

sub parse_bibtex {
  my ($self, $filename, $datatype) = @_;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);

  $logger->info("Processing $datatype format file '$filename' for section $secnum");

  my @localkeys = ();

  my $ufilename = "${filename}_$$.utf8";

  # bib encoding is not UTF-8
  if (Biber::Config->getoption('bibencoding') ne 'UTF-8') {
    require File::Slurp::Unicode;
    my $buf = File::Slurp::Unicode::read_file($filename, encoding => Biber::Config->getoption('bibencoding'))
      or $logger->logcroak("Can't read $filename");

    File::Slurp::Unicode::write_file($ufilename, {encoding => 'UTF-8'}, $buf)
      or $logger->logcroak("Can't write $ufilename");

  }
  else {
    File::Copy::copy($filename, $ufilename);
  }

  # Force bblsafechars flag if output to ASCII
  if (Biber::Config->getoption('bblencoding') =~ /(?:x-)ascii/xmsi) {
    Biber::Config->setoption('bblsafechars', 1);
  }

  # Decode LaTeX to UTF8 if output is UTF-8
  if (Biber::Config->getoption('bblencoding') eq 'UTF-8') {
    require File::Slurp::Unicode;
    my $buf = File::Slurp::Unicode::read_file($ufilename, encoding => 'UTF-8')
      or $logger->logcroak("Can't read $ufilename");
    require Biber::LaTeX::Recode;
    $logger->info('Decoding LaTeX character macros into UTF-8');
    $buf = Biber::LaTeX::Recode::latex_decode($buf, strip_outer_braces => 1,
                                                    scheme => Biber::Config->getoption('decodecharsset'));

    File::Slurp::Unicode::write_file($ufilename, {encoding => 'UTF-8'}, $buf)
        or $logger->logcroak("Can't write $ufilename");
  }

  $filename = $ufilename;

  # Increment the number of times each datafile has been referenced
  # allowing for the possible ".utf8" extra intermediate extension.
  # For example, a datafile might be referenced in more than one section.
  # Some things find this information useful, for example, setting preambles is global
  # and so we need to know if we've already saved the preamble for a datafile.
  my $basefilename = $filename;
  $basefilename =~ s/\.utf8$//;
  $BIBER_DATAFILE_REFS{$basefilename}++;

  require Biber::Input::BibTeX;
  push @ISA, 'Biber::Input::BibTeX';

  @localkeys = $self->_text_bibtex_parse($filename);

  unlink $ufilename if -f $ufilename;

  if ($section->is_allkeys) {
    map { Biber::Config->incr_seenkey($_, $section->number) } @localkeys
  }

  my $bibentries = $section->bibentries;

  # if allkeys, push all bibdata keys into citekeys (if they are not already there)
  # Can't just make citekeys = bibdata keys as this loses information about citekeys
  # that are missing data entries.
  if ($section->is_allkeys) {
    foreach my $bibkey ($bibentries->sorted_keys) {
      $section->add_citekeys($bibkey);
    }
  }

  return;
}

=head2 parse_biblatexml

    $biber->parse_biblatexml('data.xml');

    Parse a database in the BibLaTeXML format with Biber::BibLaTeXML (via
    XML::LibXML). If the suffix is dbxml, then the database is assumed to
    be stored in a Berkeley DBXML container and will be queried through the
    Sleepycat::DbXml interface.

=cut

sub parse_biblatexml {
  my ($self, $xml) = @_;
  require Biber::BibLaTeXML;
  push @ISA, 'Biber::BibLaTeXML';
  $self->_parse_biblatexml($xml);
}

=head2 check_missing

   Check for missing citation keys

=cut

sub check_missing {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bibentries;
  $logger->debug("Checking for missing citekeys in section $secnum");
  foreach my $citekey ($section->get_citekeys) {
    # Either the key refers to a real bib entry or a dynamic set entry
    unless ( $bibentries->entry_exists($citekey) or
             $section->get_dynamic_set($citekey)) {
      $logger->warn("I didn't find a database entry for '$citekey' (section $secnum)");
      $self->{warnings}++;
      $section->del_citekey($citekey);
      $section->add_undef_citekey($citekey);
      next;
    }
  }
}

=head2 process_setup

   Place to put misc pre-processing things needed later

=cut

sub process_setup {
  # Break structure information up into more processing-friendly formats
  # for use in verification checks later
  # This has to be here as opposed to in parse_control() so that it can pick
  # up structure defaults in Constants.pm in case there is no .bcf
  Biber::Config->set_structure(Biber::Structure->new(Biber::Config->getblxoption('structure')));
}

=head2 resolve_aliases

   Normalise entries by resolving any:

   * Entrytype aliases
   * Field aliases

   Defined in the structure schema passed in the .bcf

=cut

sub resolve_aliases {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bibentries;
  my $struc = Biber::Config->get_structure;

  # We are looping over all bibentries for the section, not just cited
  # entries. We have to do this to process aliases in potential crossrefs
  # which have not been processed yet. We can't process them them before this
  # as this would be ugly - crossrefs should be resolved on canonical entrytype
  # and field names which can't be done until after these are canonicalised below
  foreach my $key ($bibentries->sorted_keys) {
    my $be = $section->bibentry($key);

    # Entrytype aliases and special fields - biblatex manual Section 2.1.2
    foreach my $warning ($struc->resolve_entry_aliases($be)) {
      $self->biber_warn($be, $warning);
    }

    # Field aliases
    foreach my $warning ($struc->resolve_field_aliases($be)) {
      $self->biber_warn($be, $warning);
    }
  }
}

=head2 instantiate_dynamic

    This instantiates any dynamic entries so that they are available
    for processing later on. This has to be done before most all other
    processing so that when we call $section->bibentry($key), as we
    do many times in the code, we don't die because there is a key but
    no Entry object.

=cut

sub instantiate_dynamic {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);

  $logger->debug("Creating dynamic entries (sets/related) for section $secnum");

  # Instantiate any dynamic set entries before we do anything else
  foreach my $dset ($section->dynamic_set_keys) {
    my @members = $section->get_dynamic_set($dset);
    my $be = new Biber::Entry;
    $be->set_field('entrytype', 'set');
    $be->set_field('entryset', join(',', @members));
    $be->set_field('origkey', $dset);
    $be->set_field('citecasekey', $dset);
    $be->set_field('datatype', 'bibtex');
    $section->bibentries->add_entry($dset, $be);
    # Setting dataonly for members is handled by postprocess_sets()
  }

  # Instantiate any related entry clones we need
  foreach my $citekey ($section->get_citekeys) {
    my $be = $section->bibentry($citekey);
    if (my $relkeys = $be->get_field('related')) {
      $be->del_field('related'); # clear the related field
      my @clonekeys;
      foreach my $relkey (split /\s*,\s*/, $relkeys) {
        my $relentry = $section->bibentry($relkey);
        my $clonekey = md5_hex($relkey);
        push @clonekeys, $clonekey;
        my $relclone = $relentry->clone($clonekey);
        # clone doesn't need the related fields
        $relclone->del_field('related');
        $relclone->del_field('relatedtype');
        $section->bibentries->add_entry($clonekey, $relclone);
        Biber::Config->setblxoption('skiplab', 1, 'PER_ENTRY', $clonekey);
        Biber::Config->setblxoption('skiplos', 1, 'PER_ENTRY', $clonekey);
      }
      # point to clone keys and add to citekeys
      $section->add_citekeys(@clonekeys);
      $be->set_datafield('related', join(',', @clonekeys));
    }
  }
  return;
}


=head2 process_crossrefs

    $biber->process_crossrefs

    This does several things:
    1. Ensures that all entryset key members will be output in the bbl.
    2. Ensures proper inheritance of data from cross-references.
    3. Ensures that crossrefs/xrefs that are directly cited or cross-referenced
       at least mincrossrefs times are included in the bibliography.

=cut

sub process_crossrefs {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);

  $logger->debug("Processing explicit and implicit crossrefs for section $secnum");

  # Loop over cited keys and count the cross/xrefs
  # Can't do this when parsing .bib as this would count them for potentially uncited children
  foreach my $citekey ($section->get_citekeys) {
    my $be = $section->bibentry($citekey);
    my $refkey;
    if ($refkey = $be->get_field('xref') or $refkey = $be->get_field('crossref')) {
      $logger->debug("Incrementing cross/xrefkey count for entry '$refkey' via entry '$citekey'");
      Biber::Config->incr_crossrefkey($refkey);
    }
  }

  # promote indirectly cited inset set members to fully cited entries
  foreach my $citekey ($section->get_citekeys) {
    my $be = $section->bibentry($citekey);
    if ($be->get_field('entrytype') eq 'set') {
      my @inset_keys = split /\s*,\s*/, $be->get_field('entryset');
      foreach my $inset_key (@inset_keys) {
        $logger->debug("  Adding set member '$inset_key' to the citekeys (section $secnum)");
        $section->add_citekeys($inset_key);
      }
      # automatically crossref for the first set member using plain set inheritance
      $be->set_inherit_from($section->bibentry($inset_keys[0]));
      if ($be->get_field('crossref')) {
        $self->biber_warn($be, "Field 'crossref' is no longer needed in set entries in Biber - ignoring in entry '$citekey'");
        $be->del_field('crossref');
      }
    }
    # Do crossrefs inheritance
    if (my $crossrefkey = $be->get_field('crossref')) {
      my $parent = $section->bibentry($crossrefkey);
      $logger->debug("  Entry $citekey inheriting fields from parent $crossrefkey");
      unless ($parent) {
        $self->biber_warn($be, "Cannot inherit from crossref key '$crossrefkey' - does it exist?");
      }
      else {
        $be->inherit_from($parent);
      }
    }
  }

  # We make sure that crossrefs that are directly cited or cross-referenced
  # at least $mincrossrefs times are included in the bibliography.
  foreach my $k ( @{Biber::Config->get_crossrefkeys} ) {
    # If parent has been crossref'ed more than mincrossref times, upgrade it
    # to cited crossref status and add it to the citekeys list
    if (Biber::Config->get_crossrefkey($k) >= Biber::Config->getoption('mincrossrefs')) {
      $logger->debug("cross/xref key '$k' is cross/xref'ed >= mincrossrefs, adding to citekeys");
      $section->add_citekeys($k);
    }
  }
}

=head2 validate_structure

  Validate bib structure according to a bib schema

=cut

sub validate_structure {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $struc = Biber::Config->get_structure;

  foreach my $citekey ($section->get_citekeys) {
    my $be = $section->bibentry($citekey);
    my $et = $be->get_field('entrytype');
    if (Biber::Config->getoption('validate_structure')) {

      # default entrytype to MISC type if not a known type
      unless ($struc->is_entrytype($et)) {
        $self->biber_warn($be, "Entry '$citekey' - invalid entry type '" . $be->get_field('entrytype') . "' - defaulting to 'misc'");
        $be->set_field('entrytype', 'misc');
        $et = 'misc';           # reset this too
      }

      # Are all fields valid fields?
      # Each field must be:
      # * Valid because it's allowed for "ALL" entrytypes OR
      # * Valid field for the specific entrytype OR
      # * Valid because entrytype allows "ALL" fields
      foreach my $ef ($be->datafields) {
        unless ($struc->is_field_for_entrytype($et, $ef)) {
          $self->biber_warn($be, "Entry '$citekey' - invalid field '$ef' for entrytype '$et'");
        }
      }

      # Mandatory constraints
      foreach my $warning ($struc->check_mandatory_constraints($be)) {
        $self->biber_warn($be, $warning);
      }

      # Conditional constraints
      foreach my $warning ($struc->check_conditional_constraints($be)) {
        $self->biber_warn($be, $warning);
      }

      # Data constraints
      foreach my $warning ($struc->check_data_constraints($be)) {
        $self->biber_warn($be, $warning);
      }
    }


    # Date components - we always check these, even if not validating structure
    # as the validation is part of unpacking the *date fields
    foreach my $warning ($struc->resolve_date_components($be)) {
      $self->biber_warn($be, $warning);
    }
  }
}

=head2 postprocess

    Various postprocessing operations, mostly to generate special fields for
    biblatex. This method is automatically called by C<prepare>.
    Here we parse names, generate the "namehash" and the strings for
    "labelname", "labelyear", "labelalpha", "sortstrings", etc.

=cut

sub postprocess {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bibentries;
  foreach my $citekey ( $section->get_citekeys ) {
    $logger->debug("Postprocessing entry '$citekey' from section $secnum");

    # post process "set" entries:
    $self->postprocess_sets($citekey);

    # generate labelname name
    $self->postprocess_labelname($citekey);

    # generate labelyear name
    $self->postprocess_labelyear($citekey);

    # generate namehash,fullhash
    $self->postprocess_hashes($citekey);

    # generate uniqueness information
    $self->postprocess_unique($citekey);

    # track labelname/year combinations
    $self->postprocess_labelnameyear($citekey);

    # generate labelalpha information
    $self->postprocess_labelalpha($citekey);

    # track shorthands
    $self->postprocess_shorthands($citekey);

    # push entry-specific presort fields into the presort state
    $self->postprocess_presort($citekey);

    # first-pass sorting to generate basic labels
    $self->postprocess_generate_sortinfo_label($citekey);
  }

  $logger->debug("Finished postprocessing entries in section $secnum");

  return;
}

=head2 postprocess_sets

    Postprocess set entries

    Checks for common set errors and enforces 'dataonly' for set members

=cut

sub postprocess_sets {
  my $self = shift;
  my $citekey = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bibentries;
  my $be = $bibentries->entry($citekey);
  if ($be->get_field('entrytype') eq 'set') {
    my @entrysetkeys = split /\s*,\s*/, $be->get_field('entryset');

    # Enforce Biber parts of virtual "dataonly" for set members
    # Also automatically create an "entryset" field for the members
    foreach my $member (@entrysetkeys) {
      Biber::Config->setblxoption('skiplab', 1, 'PER_ENTRY', $member);
      Biber::Config->setblxoption('skiplos', 1, 'PER_ENTRY', $member);
      my $me = $bibentries->entry($member);
      if ($me->get_field('entryset')) {
        $self->biber_warn($me, "Field 'entryset' is no longer needed in set member entries in Biber - ignoring in entry '$member'");
        $me->del_field('entryset');
      }
      # This ends up setting \inset{} in the bib
      $me->set_field('entryset', $citekey);
    }

    unless (@entrysetkeys) {
      $self->biber_warn($be, "No entryset found for entry $citekey of type 'set'");
    }
  }
  # check if this non-set entry is in a cited set and if so, we
  # have enforced Biber parts of virtual "dataonly" otherwise
  # this entry will spuriously generate disambiguation data for itself
  # This would only happen if the non-set entry was cited before any set
  # in which it occurred of course since otherwise it would have already had
  # "dataonly" enforced by the code above
  else {
    foreach my $pset_key ($section->get_citekeys) {
      my $pset_be = $bibentries->entry($pset_key);
      if ($pset_be->get_field('entrytype') eq 'set') {
        my @entrysetkeys = split /\s*,\s*/, $pset_be->get_field('entryset');
        foreach my $member (@entrysetkeys) {
          next unless $member eq $citekey;
          # Posssible that this has already been set if this set entry member
          # was dealt with above but in case we haven't seen the set it's in yet ...
          Biber::Config->setblxoption('skiplab', 1, 'PER_ENTRY', $member);
          Biber::Config->setblxoption('skiplos', 1, 'PER_ENTRY', $member);
        }
      }
    }
  }
}

=head2 postprocess_labelname

    Generate labelname information. Fields set are:

    * labelnamename - the name of the labelname field to use
    * labelnamenamefullhash - the name of the labelname field to use for
                              fulhash generation.

    We can retreive the actual labelname value later with:

    $entry->get_field($entry->get_field('labelnamename))

    It's neat this way as we often need to know what the labelname field is
    as well as it's actual string value

=cut

sub postprocess_labelname {
  my $self = shift;
  my $citekey = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bibentries;
  my $be = $bibentries->entry($citekey);
  my $lnamescheme = Biber::Config->getblxoption('labelname', $be->get_field('entrytype'));
  # First we set the normal labelname name
  foreach my $ln ( @{$lnamescheme} ) {
    my $lnameopt;
    if ( $ln =~ /\Ashort(.+)\z/ ) {
      $lnameopt = $1;
    } else {
      $lnameopt = $ln;
    }
    if ($be->get_field($ln) and
      Biber::Config->getblxoption("use$lnameopt", $be->get_field('entrytype'), $citekey ) ) {
      $be->set_field('labelnamename', $ln);
      last;
    }
  }

  # Then we loop again to set the labelname name for the fullhash generation code
  # This is because fullhash generation ignores SHORT* fields (section 4.2.4.1, BibLaTeX
  # manual)
  foreach my $ln ( @{$lnamescheme} ) {
    if ( $ln =~ /\Ashort(.+)\z/ ) {
      next;
    }
    if ($be->get_field($ln) and
      Biber::Config->getblxoption("use$ln", $be->get_field('entrytype'), $citekey ) ) {
      $be->set_field('labelnamenamefullhash', $ln);
      last;
    }
  }

  # Generate the actual labelname
  if ($be->get_field('labelnamename')) {
    $be->set_field('labelname', $be->get_field($be->get_field('labelnamename')));
  }
  else {
    $logger->debug("Could not determine the labelname of entry $citekey");
  }
}

=head2 postprocess_labelyear

    Generate labelyear
    Here, "labelyearname" is the name of the labelyear field
    and "labelyear" is the actual copy of the relevant field

=cut

sub postprocess_labelyear {
  my $self = shift;
  my $citekey = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bibentries;
  my $be = $bibentries->entry($citekey);
  my $lyearscheme = Biber::Config->getblxoption('labelyear', $be->get_field('entrytype'));

  if ($lyearscheme) {
    if (Biber::Config->getblxoption('skiplab', $be->get_field('entrytype'), $citekey)) {
      return;
    }
    # make sure we gave the correct data type:
    $logger->logcroak("Invalid value for option labelyear: $lyearscheme\n")
      unless ref $lyearscheme eq 'ARRAY';
    foreach my $ly ( @{$lyearscheme} ) {
      if ($be->get_field($ly)) {
        $be->set_field('labelyearname', $ly);
        last;
      }
    }

    # Construct labelyear
    # Might not have been set due to skiplab/dataonly
    if (my $yf = $be->get_field('labelyearname')) {
      $be->set_field('labelyear', $be->get_field($yf));

      # ignore endyear if it's the same as year
      my ($ytype) = $yf =~ /\A(.*)year\z/xms;
      # endyear can be null
      if (is_def_and_notnull($be->get_field($ytype . 'endyear'))
        and ($be->get_field($yf) ne $be->get_field($ytype . 'endyear'))) {
        $be->set_field('labelyear',
          $be->get_field('labelyear') . '\bibdatedash ' . $be->get_field($ytype . 'endyear'));
      }
    }
    else {
      $logger->debug("Could not determine the labelyearname of entry $citekey");
    }
  }
}

=head2 postprocess_hashes

    Generate namehash and fullhash

=cut

sub postprocess_hashes {
  my $self = shift;
  my $citekey = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bibentries;
  my $be = $bibentries->entry($citekey);
  my $bee = $be->get_field('entrytype');
  my $namehash = ''; # biblatex namehash field (manual, section 4.2.4.1)
  my $fullhash = ''; # biblatex fullhash field (manual, section 4.2.4.1)
  my $nameid   = '';

  # namehash is generated from the labelname
  if (my $lname = $be->get_field('labelnamename')) {
    if (my $ln = $be->get_field($lname)) {
      $namehash .= $self->_getnamehash($citekey, $ln);
      $nameid .= makenameid($ln);
    }
  }
  # fullhash is generated from the labelname but ignores SHORT* fields and
  # maxnames/minnames settings
  if (my $lnamefh = $be->get_field('labelnamenamefullhash')) {
    if ($be->get_field($lnamefh)) {
      $fullhash .= $self->_getfullhash($citekey, $be->get_field($lnamefh));
    }
  }

  # After the initial generation of namehash and fullhash, we have to append
  # a suffix as they must be unique. It is possible that different entries have
  # the same hashes at this stage. For example:

  # AUTHOR = {Fred Grimble and Bill Bullter} = "FGBB"
  # AUTHOR = {Frank Garby and Brian Blunkley} = "FGBB"

  my $hashsuffix = 1;

  # First, check to see if we've already seen this exact name before
  if (Biber::Config->get_namehashcount($namehash, $nameid)) {
    # If we have, our suffix is already known
    $hashsuffix = Biber::Config->get_namehashcount($namehash, $nameid);
  }
  # Otherwise, if the namehash already exists, we'll make a new entry with a new suffix
  elsif (Biber::Config->namehashexists($namehash)) {
    # Count the suffixes already defined ...
    my $count = Biber::Config->get_numofnamehashes($namehash);
    # ... add one to the number ...
    $hashsuffix = $count + 1;
    # ... and define a new suffix for that name
    Biber::Config->set_namehashcount($namehash, $nameid, $hashsuffix);
  }
  # No entry for the namehash at all so make a new one, a new name and suffix
  else {
    Biber::Config->del_namehash($namehash);
    Biber::Config->set_namehashcount($namehash, $nameid, 1);
  }

  # Now append the suffices, making the hashes unique
  $namehash .= $hashsuffix;
  $fullhash .= $hashsuffix;

  # Set the hashes
  $be->set_field('namehash', $namehash);
  $be->set_field('fullhash', $fullhash);

  # Don't add to disambiguation data if skiplab is set
  unless (Biber::Config->getblxoption('skiplab', $bee, $citekey)) {
    Biber::Config->incr_seennamehash($fullhash);
  }
}

=head2 postprocess_unique

    Generate uniqueness information. This is used later to generate unique* fields

=cut

sub postprocess_unique {
  my $self = shift;
  my $citekey = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bibentries;
  my $be = $bibentries->entry($citekey);
  my $bee = $be->get_field('entrytype');
  my $namehash = $be->get_field('namehash');

  # Set uniquename, if required
  # Note that we don't determine if a name is unique here -
  # we can't, were still processing entries at this point.
  # Here we are just recording seen combinations of:
  #
  # lastnames and what hashes were generated from them (uniquename = 0)
  # lastnames+initials and what hashes were generated from them (uniquename = 1)
  #
  # Naturally, anything which has more than one combination for both of these would
  # be uniquename = 2
  #
  # See the logic in Internals.pm for generating the actual uniquename count
  # from the information collected here
  if (Biber::Config->getblxoption('uniquename', $bee)) {
    my $lname = $be->get_field('labelnamename');
    my $lastname;
    my $namestring;
    my $singlename;

    # uniquename only works (currently) with single names
    if ($lname) {
      $lastname   = $be->get_field($lname)->nth_element(1)->get_lastname;
      $namestring = $be->get_field($lname)->nth_element(1)->get_nameinitstring;
      $singlename = $be->get_field($lname)->count_elements;
    }

    # If we need to provide uniquename, labelnamename exists and we are only
    # dealing with a single name
    if ($lname and $singlename == 1 ) {
      # Record a uniqueness information entry for the lastname showing that
      # this lastname has been seen in the name with the namehash
      Biber::Config->add_uniquenamecount($lastname, $namehash);

      # Record a uniqueness information entry for the lastname+initials showing that
      # this lastname_initials has been seen in the name with the namehash
      Biber::Config->add_uniquenamecount($namestring, $namehash);
    }
    else {
      $be->set_field('ignoreuniquename', 1);
    }
  }
}

=head2 postprocess_labelnameyear

    Track author/year combination

=cut

sub postprocess_labelnameyear {
  my $self = shift;
  my $citekey = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bibentries;
  my $be = $bibentries->entry($citekey);
  # This is all used to generate extrayear and the rules for this are:
  # * Generate labelname/year combination for tracking extrayear
  # * If there is no labelname to use, use empty string
  # * If there is no labelyear to use, use empty string
  # * Don't increment the seen_extra* count if either name or year string is empty
  #   (see code in incr_seen_extra* methods).
  # * Don't increment if skiplab is set

  my $name_string;
  # For tracking name/year combinations, use shorthand only if it exists and we
  # are using labelyear
  if ( Biber::Config->getblxoption('labelalpha', $be->get_field('entrytype')) and
       $be->get_field('shorthand')) {
    $name_string = $be->get_field('shorthand');
  }
  elsif (my $lnn = $be->get_field('labelnamename')) {
    $name_string = $self->_namestring($citekey, $lnn);
  }
  else {
    $name_string = '';
  }

  # extrayear takes into account the labelyear which can be a range
  my $year_string_extrayear;
  if (my $ly = $be->get_field('labelyear')) {
    $year_string_extrayear = $ly;
  }
  elsif (my $y = $be->get_field('year')) {
    $year_string_extrayear = $y;
  }
  else {
    $year_string_extrayear = '';
  }

  # extraalpha takes into account the "year of publication" and not ranges as it
  # only has the last two digits of the year and so can't disambiguate using ranges
  # so, we have to track it separately to extrayear
  my $year_string_extraalpha;
  if (my $y = $be->get_field('year')) {
    $year_string_extraalpha = $y;
  }
  else {
    $year_string_extraalpha = '';
  }

  # Don't create disambiguation data for skiplab entries
  unless (Biber::Config->getblxoption('skiplab',
                                      $be->get_field('entrytype'),
                                      $be->get_field('origkey'))) {
    my $nameyear_string_extrayear  = "$name_string,$year_string_extrayear";
    $be->set_field('nameyear_extrayear', $nameyear_string_extrayear);
    Biber::Config->incr_seen_nameyear_extrayear($name_string, $year_string_extrayear);
    my $nameyear_string_extraalpha = "$name_string,$year_string_extraalpha";
    $be->set_field('nameyear_extraalpha', $nameyear_string_extraalpha);
    Biber::Config->incr_seen_nameyear_extraalpha($name_string, $year_string_extraalpha);
  }
}

=head2 postprocess_labelalpha

    Generate the labelalpha and also the variant for sorting

=cut

sub postprocess_labelalpha {
  my $self = shift;
  my $citekey = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bibentries;
  my $be = $bibentries->entry($citekey);
  my $bee = $be->get_field('entrytype');
  # Don't add a label if skiplab is set for entry
  if (Biber::Config->getblxoption('skiplab', $bee, $citekey)) {
    return;
  }
  if ( Biber::Config->getblxoption('labelalpha', $be->get_field('entrytype')) ) {
    my $label;
    my $sortlabel;

    if ( $be->get_field('shorthand') ) {
      $sortlabel = $label = $be->get_field('shorthand');
    }
    else {
      if ( $be->get_field('label') ) {
        $sortlabel = $label = $be->get_field('label');
      }
      elsif ( $be->get_field('labelnamename') and $be->get_field($be->get_field('labelnamename'))) {
        ( $label, $sortlabel ) =
          @{ $self->_getlabel( $citekey, $be->get_field('labelnamename') ) };
      }
      else {
        $sortlabel = $label = '';
      }

      # biblatex manual says "publication year"
      if ( my $year = $be->get_field('year') ) {
        my $yr;
        # Make "in press" years look nice in alpha styles
        if ($year =~ m/\A\s*in\s*press\s*\z/ixms) {
          $yr = 'ip';
        }
        # Normal year
        else {
          $yr = substr $year, 2, 2;
        }
        $label     .= $yr;
        $sortlabel .= $yr;
      }
    }
    $be->set_field('labelalpha', $label);
    $be->set_field('sortlabelalpha', $sortlabel);
  }
}

=head2 postprocess_shorthands

    Track shorthands

=cut

sub postprocess_shorthands {
  my $self = shift;
  my $citekey = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bibentries;
  my $be = $bibentries->entry($citekey);
  my $bee = $be->get_field('entrytype');
  if ( my $sh = $be->get_field('shorthand') ) {
    $section->add_shorthand($bee, $citekey);
  }
}

=head2 postprocess_presort

    Put presort fields for an entry into the main Biber bltx state
    so that it's all available in the same place since this can be
    set per-type and globally too.

=cut

sub postprocess_presort {
  my $self = shift;
  my $citekey = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bibentries;
  my $be = $bibentries->entry($citekey);
  # We are treating presort as an option as it can be set per-type and globally too
  if (my $ps = $be->get_field('presort')) {
    Biber::Config->setblxoption('presort', $ps, 'PER_ENTRY', $citekey);
  }
}

=head2 postprocess_generate_sortinfo_label

    Generate label pass of sorting information

=cut

sub postprocess_generate_sortinfo_label {
  my $self = shift;
  my $citekey = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bibentries;
  my $be = $bibentries->entry($citekey);
  $self->_generatesortinfo( $citekey, Biber::Config->getblxoption('sorting')->{label});
}

=head2 generate_final_sortinfo

    Generate:

      * extraalpha
      * extrayear

    For use in final sorting and generate final pass sort string

=cut

sub generate_final_sortinfo {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bibentries;
  # This loop critically depends on the order of the citekeys which
  # is why we have to do a first sorting pass before this
  foreach my $citekey ($section->get_citekeys) {
    my $be = $bibentries->entry($citekey);
    my $bee = $be->get_field('entrytype');
    # Only generate extrayear and extraalpha if skiplab is not set.
    # Don't forget that skiplab is implied for set members
    unless (Biber::Config->getblxoption('skiplab', $bee, $citekey)) {
      my $nameyear_extrayear = $be->get_field('nameyear_extrayear');
        if (Biber::Config->getblxoption('labelyear', $be->get_field('entrytype'))) {
          if (Biber::Config->get_seen_nameyear_extrayear($nameyear_extrayear) > 1) {
            $be->set_field('extrayear', Biber::Config->incr_seen_extrayear($nameyear_extrayear));
        }
      }
      my $nameyear_extraalpha = $be->get_field('nameyear_extraalpha');
        if (Biber::Config->getblxoption('labelalpha', $be->get_field('entrytype'))) {
          if (Biber::Config->get_seen_nameyear_extraalpha($nameyear_extraalpha) > 1) {
            $be->set_field('extraalpha', Biber::Config->incr_seen_extraalpha($nameyear_extraalpha));
        }
      }
    }
    $self->_generatesortinfo($citekey, Biber::Config->getblxoption('sorting')->{final});
  }
  return;
}

=head2 sortentries

    Sort the entries according to a certain sorting scheme.
    Use a flag to skip info messages on first pass

=cut

sub sortentries {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bibentries;
  my @citekeys = $section->get_citekeys;
  if (Biber::Config->getoption('sortcase')) {
    $logger->debug("Sorting is by default case-SENSITIVE");
  }
  else {
    $logger->debug("Sorting is by default case-INSENSITIVE");
  }
  $logger->debug("Citekeys before sort:\n");
  foreach my $ck (@citekeys) {
    $logger->debug("$ck => " . $bibentries->entry($ck)->get_field('sortstring') . "\n");
  }

  # Get the right sortscheme
  my $sortscheme;
  if ($BIBER_SORT_FIRSTPASSDONE) {
    $sortscheme = Biber::Config->getblxoption('sorting')->{final};
  }
  else {
    $sortscheme = Biber::Config->getblxoption('sorting')->{label};
  }

  # Set up locale. Order of priority is:
  # 1. locale value passed to Unicode::Collate::Locale->new() (Unicode::Collate sorts only)
  # 2. Biber sortlocale option
  # 3. LC_COLLATE env variable
  # 4. LANG env variable
  # 5. LC_ALL env variable
  # 6. Built-in defaults

  my $thislocale = Biber::Config->getoption('sortlocale');
  if ( Biber::Config->getoption('fastsort') ) {
    use locale;
    $logger->info("Sorting entries with built-in sort (with locale $thislocale) ...") if $BIBER_SORT_FIRSTPASSDONE;

    unless (setlocale(LC_ALL, $thislocale)) {
      if ($BIBER_SORT_FIRSTPASSDONE) {
        $logger->warn("Unavailable locale $thislocale");
        $self->{warnings}++;
      }
    }

    # Construct a multi-field Schwartzian Transform with the right number of
    # extractions into a string representing an array ref as we musn't eval this yet
    my $num_sorts = 0;
    my $data_extractor = '[';
    my $sorter;
    my $sort_extractor;
    # Global lowercase setting
    my $glc = Biber::Config->getoption('sortcase') ? '' : 'lc ';

    foreach my $sortset (@{$sortscheme}) {
      $data_extractor .= '$bibentries->entry($_)->get_field("sortobj")->[' . $num_sorts . '],';
      $sorter .= ' || ' if $num_sorts; # don't add separator before first field
      my $lc = $glc; # Casing defaults to global default ...
      my $sc = $sortset->[0]{sortcase};
      # but is overriden by field setting if it exists
      if (defined($sc) and $sc != Biber::Config->getoption('sortcase')) {
        unless ($sc) {
          $lc = 'lc ';
        }
        else {
          $lc = '';
        }
      }

      my $sd = $sortset->[0]{sort_direction};
      if (defined($sd) and $sd eq 'descending') {
        # descending field
        $sorter .=
          $lc .
            '$b->[' .
              $num_sorts .
                '] cmp ' .
                  $lc .
                    '$a->[' .
                      $num_sorts .
                        ']';
      }
      else {
        # ascending field
        $sorter .=
          $lc .
            '$a->[' .
              $num_sorts .
                '] cmp ' .
                  $lc .
                    '$b->[' .
                      $num_sorts .
                        ']';
      }
      $num_sorts++;
    }
    $data_extractor .= '$_]';
    # Handily, $num_sorts is now one larger than the number of fields which is the
    # correct index for the actual data in the sort array
    $sort_extractor = '$_->[' . $num_sorts . ']';

    # Schwartzian transform multi-field sort
    @citekeys = map  { eval $sort_extractor }
                sort { eval $sorter }
                map  { eval $data_extractor } @citekeys;

  }
  else {
    require Unicode::Collate::Locale;
    my $opts = Biber::Config->getoption('collate_options');
    my $collopts;
    unless (ref($opts) eq "HASH") { # opts for this can come in a string from cmd line
      $collopts = eval "{ $opts }" or $logger->logcarp("Incorrect collate_options: $@");
    }
    else { # options from config file as hash ref
      $collopts = $opts;
    }

    # UCA level 2 if case insensitive sorting is requested
    unless (Biber::Config->getoption('sortcase')) {
      $collopts->{level} = 2;
    }

    # Add upper_before_lower option
    $collopts->{upper_before_lower} = Biber::Config->getoption('sortupper');

    # Add tailoring locale for Unicode::Collate
    if ($thislocale and not $collopts->{locale}) {
      $collopts->{locale} = $thislocale;
      if ($collopts->{table}) {
        my $t = delete $collopts->{table};
        $logger->info("Ignoring collation table '$t' as locale is set ($thislocale)") if $BIBER_SORT_FIRSTPASSDONE;
      }
    }

    # Remove locale from options as we need this to make the object
    my $coll_locale = delete $collopts->{locale};
    # Now create the collator object
    my $Collator = Unicode::Collate::Locale->new( locale => $coll_locale )
      or $logger->logcarp("Problem with Unicode::Collate options: $@");

    # Tailor the collation object and report differences from defaults for locale
    # Have to do this in ->change method a ->new can croak with conflicting tailoring
    # for locales which enforce certain tailorings
    my %coll_changed = $Collator->change( %{$collopts} );
    while (my ($k, $v) = each %coll_changed) {
      # If we changing something that has no override tailoring in the locale, it
      # is undef in this hash and we don't care about such things
      next unless defined($coll_changed{$k});
      if ($coll_changed{$k} ne $collopts->{$k}) {
        $logger->warn("Overriding locale '$coll_locale' default tailoring '$k = $v' with '$k = " . $collopts->{$k} . "'") if $BIBER_SORT_FIRSTPASSDONE;
      }
    }

    my $UCAversion = $Collator->version();
    $logger->info("Sorting entries with Unicode::Collate (" .
		  stringify_hash($collopts) . ", UCA version: $UCAversion)") if $BIBER_SORT_FIRSTPASSDONE;
    # Log if U::C::L currently has no tailoring for used locale
    if ($Collator->getlocale eq 'default') {
      $logger->info("No sort tailoring available for locale '$thislocale'") if $BIBER_SORT_FIRSTPASSDONE;
    }

    # Construct a multi-field Schwartzian Transform with the right number of
    # extractions into a string representing an array ref as we musn't eval this yet
    my $num_sorts = 0;
    my $data_extractor = '[';
    my $sorter;
    my $sort_extractor;
    foreach my $sortset (@{$sortscheme}) {
      my $fc = '';
      my @fc;
      # Reset collation object to global defaults for each sortset in case
      # locally overriden by earlier loop
      $Collator->change(level              => $collopts->{level},
                        upper_before_lower => $collopts->{upper_before_lower});

      # If the case or upper option on a field is not the global default
      # set it locally on the $Collator by constructing a change() method call
      my $sc = $sortset->[0]{sortcase};
      if (defined($sc) and $sc != Biber::Config->getoption('sortcase')) {
        push @fc, $sc ? 'level => 4' : 'level => 2';
      }
      my $su = $sortset->[0]{sortupper};
      if (defined($su) and $su != Biber::Config->getoption('sortupper')) {
        push @fc, $su ? 'upper_before_lower => 1' : 'upper_before_lower => 0';
      }
      if (@fc) {
        $fc = '->change(' . join(',', @fc) . ')'
      }

      $data_extractor .= '$bibentries->entry($_)->get_field("sortobj")->[' . $num_sorts . '],';
      $sorter .= ' || ' if $num_sorts; # don't add separator before first field

      my $sd = $sortset->[0]{sort_direction};
      if (defined($sd) and $sd eq 'descending') {
        # descending field
        $sorter .= '$Collator' .
          $fc .
          '->cmp($b->[' .
          $num_sorts .
            '],$a->[' .
              $num_sorts .
                '])';
      }
      else {
        # ascending field
        $sorter .= '$Collator' .
          $fc .
          '->cmp($a->[' .
          $num_sorts .
            '],$b->[' .
              $num_sorts .
                '])';
      }
      $num_sorts++;
    }
    $data_extractor .= '$_]';
    # Handily, $num_sorts is now one larger than the number of fields which is the
    # correct index for the actual data in the sort array
    $sort_extractor = '$_->[' . $num_sorts . ']';

    $logger->debug('Sorter method: ' . $sorter);

    # Schwartzian transform multi-field sort
    @citekeys = map  { eval $sort_extractor }
                sort { eval $sorter }
                map  { eval $data_extractor } @citekeys;

  }

  $logger->debug("Citekeys after sort:\n");
  foreach my $ck (@citekeys) {
    $logger->debug("$ck => " . $bibentries->entry($ck)->get_field('sortstring') . "\n");
  }
  $section->set_citekeys([ @citekeys ]);

  return;
}

=head2 sort_shorthands

    Sort the shorthands according to a certain sorting scheme.
    If sortlos = 1 (los), sort by shorthand
    If sortlos = 0 (bib), sort by bibliography order

=cut

sub sort_shorthands {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bibentries;
  my @shorthands = $section->get_shorthands;
  my @citekeys = $section->get_citekeys;
  my $key_index;
  my %citekeys = map {$_ => $key_index++} @citekeys;
  # What we sort on depends on the 'sortlos' BibLaTeX option
  my $thislocale = Biber::Config->getoption('sortlocale');

  # sort by sortkey - this means shorthands should be in same order as
  # citekeys which has already been sorted so just sort on the index each
  # shorthand (which is a citekeys) occurs in @citekeys
  unless (Biber::Config->getblxoption('sortlos')) {
    $logger->debug("Sorting shorthands by 'sortkey'");
    @shorthands = sort {$citekeys{$a} <=> $citekeys{$b}} @shorthands;
  }
  else {
    # sort by shorthands so we actually have to sort by the shorthand values
    if ( Biber::Config->getoption('fastsort') ) {
      use locale;
      $logger->info("Sorting shorthands with built-in sort (with locale $thislocale) ...");
      unless (setlocale( LC_ALL, $thislocale )) {
        $logger->warn("Unavailable locale $thislocale");
        $self->{warnings}++;
      }
      $logger->debug("Sorting shorthands by 'shorthand'");
      @shorthands = sort { $bibentries->entry($a)->get_field('shorthand') cmp $bibentries->entry($b)->get_field('shorthand') } @shorthands;
    }
    else {
      require Unicode::Collate::Locale;
      my $opts = Biber::Config->getoption('collate_options');
      my $collopts;
      unless (ref($opts) eq "HASH") { # opts for this can come in a string from cmd line
        $collopts = eval "{ $opts }" or $logger->logcarp("Incorrect collate_options: $@");
      }
      else {
        $collopts = $opts;
      }

      # UCA level 2 if case insensitive sorting is requested
      unless (Biber::Config->getoption('sortcase')) {
        $collopts->{level} = 2;
      }

      # Add upper_before_lower option
      $collopts->{upper_before_lower} = Biber::Config->getoption('sortupper');

      # Add tailoring locale for Unicode::Collate
      if ($thislocale and not $collopts->{locale}) {
        $collopts->{locale} = $thislocale;
        if ($collopts->{table}) {
          my $t = delete $collopts->{table};
          $logger->info("Ignoring collation table '$t' as locale is set ($thislocale)");
        }
      }

      # Remove locale from options as we need this to make the object
      my $coll_locale = delete $collopts->{locale};
      # Now create the collator object
      my $Collator = Unicode::Collate::Locale->new( locale => $coll_locale )
        or $logger->logcarp("Problem with Unicode::Collate options: $@");

      # Note reporting tailoring locale default overrides here since we already
      # do that during main sorting and the tailoring can't change by the time
      # we get here
      # Still using ->change though so we don't die on tailoring option conflicts
      $Collator->change( %{$collopts} );

      my $UCAversion = $Collator->version();
      $logger->info("Sorting shorthands with Unicode::Collate (" .
                    stringify_hash($collopts) . ", UCA version: $UCAversion)");

      $logger->debug("Sorting shorthands by 'shorthand'");
      @shorthands = sort {
        $Collator->cmp( $bibentries->entry($a)->get_field('shorthand'),
                        $bibentries->entry($b)->get_field('shorthand') )
      } @shorthands;
    }
  }
  $section->set_shorthands([ @shorthands ]);
  return;
}

=head2 prepare

    Do the main work.
    Process and sort all entries before writing the bbl output.

=cut

sub prepare {
  my $self = shift;
  $self->process_setup;                # Place to put global pre-processing things
  foreach my $section (@{$self->sections->get_sections}) {
    # shortcut - skip sections that don't have any keys
    next unless $section->get_citekeys or $section->is_allkeys;

    my $secnum = $section->number;
    # Remove any dynamically generated per-entry options which might have
    # been set in previous sections (like skiplab, skiplos)
    Biber::Config->reset_per_entry_options;

    $BIBER_SORT_FIRSTPASSDONE = 0;       # sanitise sortpass flag
    $logger->info("Processing bib section $secnum");
    Biber::Config->_init;                # (re)initialise Config object
    $self->set_current_section($secnum); # Set the section number we are working on
    $self->parse_data;                   # Parse data into section objects
    $self->check_missing;                # Check for missing citekeys before anything else
    $self->resolve_aliases;              # Resolve entrytype/field aliases to normalise entries
    $self->instantiate_dynamic;          # Instantiate any dynamic entries (sets, related)
    $self->process_crossrefs;            # Process crossrefs/sets
    $self->validate_structure;           # Check bib structure
    $self->postprocess;                  # Main entry postprocessing
    $self->sortentries;                  # then we do a label sort pass and set a flag
    $BIBER_SORT_FIRSTPASSDONE = 1;
    $self->generate_final_sortinfo;      # in here we generate the final sort information
    $self->sortentries;                  # and then we do a final sort pass
    $self->create_output_section;        # Generate and push the section output into the
                                         # output object ready for writing
  }
  $self->create_output_misc;             # Generate and push the final misc bits of output
                                         # into the output object ready for writing
  return;
}

=head2 parse_data

    Read the data file(s) for the section and store it in the section object

=cut

sub parse_data {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);

  # Clear all T::B macro definitions between sections.
  # T::B never clears these
  Text::BibTeX::delete_all_macros;

  foreach my $datafile ($section->get_datafiles) {
    my $name = $datafile->{name};
    my $datatype = $datafile->{datatype};
    $name .= '.bib' unless $name =~ /\.(?:bib|xml|dbxml)\z/xms;
    my $dfname;
    if ($dfname = locate_biber_file($name)) {
      $logger->info("Found $datatype data file '$dfname'");
    }
    else {
      $logger->logcroak("File '$name' does not exist!")
    }
    # Here we decide which parser to use for the data file
    if ($datatype eq 'bibtex') {
      $self->parse_bibtex($dfname, $datatype);
    }
  }
  return;
}

=head2 create_output_section

    Create the output from the sections data and push it into the
    output object. You can subclass Biber and
    override this method to output things other than .bbl

=cut

sub create_output_section {
  my $self = shift;
  my $output_obj = $self->get_output_obj;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);

  my @citekeys = $section->get_citekeys;
  my @undef_citekeys = $section->get_undef_citekeys;
  # We rely on the order of this array for the order of the .bbl
  foreach my $k (@citekeys) {
    # Regular entry
    my $be = $section->bibentry($k) or $logger->logcroak("Cannot find entry with key '$k' to output");
    $output_obj->set_output_entry($be, $section, Biber::Config->get_structure);
  }
  # Missing citekeys
  foreach my $k (@undef_citekeys) {
    $output_obj->set_output_undefkey($k, $section);
  }
  # Push the sorted shorthands for each section into the output object
  if ( $section->get_shorthands ) {
    $self->sort_shorthands;
    $output_obj->set_los([ $section->get_shorthands ], $secnum);
  }

  return;
}

=head2 create_output_misc

    Create the output for misc bits and pieces like preamble and closing
    macro call and add to output object. You can subclass Biber and
    override this method to output things other than .bbl

=cut

sub create_output_misc {
  my $self = shift;
  my $output_obj = $self->get_output_obj;

  if (my $pa = $self->{preamble}) {
    $pa = join("%\n", @$pa);
    # Decode UTF-8 -> LaTeX macros if asked to
    if (Biber::Config->getoption('bblsafechars')) {
      require Biber::LaTeX::Recode;
      $pa = Biber::LaTeX::Recode::latex_encode($pa,
                                               scheme => Biber::Config->getoption('bblsafecharsset'));
    }
    $output_obj->add_output_head("\\preamble{%\n$pa%\n}\n\n");
  }

  $output_obj->add_output_tail("\\endinput\n\n");
  return;
}


=head2 _filedump and _stringdump

    Dump the biber object with Data::Dump for debugging

=cut

sub _filedump {
  my ($self, $file) = @_;
  my $fh = IO::File->new($file, '>') or croak "Can't open file $file for writing";
  print $fh Data::Dump::pp($self);
  close $fh;
  return
}

sub _stringdump {
  my $self = shift ;
  return Data::Dump::pp($self);
}

=head1 AUTHORS

Franois Charette, C<< <firmicus at gmx.net> >>
Philip Kime C<< <philip at kime.org.uk> >>

=head1 BUGS

Please report any bugs or feature requests on our sourceforge tracker at
L<https://sourceforge.net/tracker2/?func=browse&group_id=228270>.

=head1 COPYRIGHT & LICENSE

Copyright 2009-2011 Franois Charette and Philip Kime, all rights reserved.

This module is free software.  You can redistribute it and/or
modify it under the terms of the Artistic License 2.0.

This program is distributed in the hope that it will be useful,
but without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

=cut

1;

# vim: set tabstop=2 shiftwidth=2 expandtab:
