package Biber;
use strict;
use warnings;
use Carp;
use IO::File;
use File::Spec;
use Encode;
use POSIX qw( locale_h ); # for sorting with built-in "sort"
use IPC::Cmd qw( can_run run );
use Cwd qw( abs_path );
use Biber::Config;
use Biber::Constants;
use List::Util qw( first );
use Biber::Internals;
use Biber::Entries;
use Biber::Entry;
use Biber::Entry::Name;
use Biber::Sections;
use Biber::Section;
use Biber::Utils;
use LaTeX::Decode;
use Storable qw( dclone );
use Log::Log4perl qw( :no_extra_logdie_message );
use base 'Biber::Internals';
use Config::General qw( ParseConfig );
use Data::Dump;
our @ISA;

=encoding utf-8

=head1 NAME

Biber - main module for biber, a bibtex replacement for users of biblatex

=head1 VERSION

Version 0.5.3

=cut

our $VERSION = '0.5.3';

=head1 SYNOPSIS

    use Biber;

    my $biber = Biber->new();
    $biber->parse_ctrlfile("example.bcf");
    $biber->prepare;

=cut

my $logger = Log::Log4perl::get_logger('main');

=head1 METHODS

=head2 new

    Initialize the Biber object, optionally passing named options as arguments.

    my $biber = Biber->new( fastsort => 1, datafile => 'biblatex.xml', outfile => 'test.bbl' );

=cut

sub new {
  my ($class, %opts) = @_;
  my $self = bless {}, $class;

  # Set up config object.
  if (defined $opts{configfile}) {
    Biber::Config->_initopts( $opts{configfile} );
  } else {
    Biber::Config->_initopts(undef, $opts{noconf});
  }
  if (%opts) {
    foreach (keys %opts) {
      Biber::Config->setcmdlineoption($_, $opts{$_});
    }
  }
  return $self;
}

=head2 sections

    my $sections= $biber->sections

    Returns a Biber::Sections object describing the bibliography sections

=cut

sub sections {
  my $self = shift;
  return $self->{sections};
}

=head2 set_output_obj

    Sets the object used to output final results
    Must be a subclass of Biber::Output::Base

=cut

sub set_output_obj {
  my $self = shift;
  my $obj = shift;
  croak('Output object must be subclass of Biber::Output::Base!') unless $obj->isa('Biber::Output::Base');
  $self->{output_obj} = $obj;
  return;
}

=head2 get_preamble

    Returns the current preamble as an array ref

=cut

sub get_preamble {
  my $self = shift;
  return $self->{preamble};
}


=head2 get_output_obj

    Returns the object used to output final results

=cut

sub get_output_obj {
  my $self = shift;
  return $self->{output_obj};
}

=head2 set_current_section

    Sets the current section number that we are working on to a section number

=cut

sub set_current_section {
  my $self = shift;
  my $secnum = shift;
  $self->{current_section} = $secnum;
  return;
}

=head2 get_current_section

    Gets the current section number that we are working on

=cut

sub get_current_section {
  my $self = shift;
  return $self->{current_section};
}


=head2 parse_ctrlfile

    This method reads the control file
    generated by biblatex to figure out the various biblatex options.
    See Constants.pm for defaults and example of the data structure being built here.

=cut

sub parse_ctrlfile {
  my ($self, $ctrl_file) = @_;

  $logger->logcroak("Cannot find control file '$ctrl_file'! - did you pass the \"backend=biber\" option to BibLaTeX?") unless -f "$ctrl_file";

  # Validate if asked to
  if (Biber::Config->getoption('validate')) {
    require XML::LibXML;

    # Set up XML parser
    my $CFxmlparser = XML::LibXML->new();
    $CFxmlparser->line_numbers(1); # line numbers for more informative errors

    # Set up schema
    my $CFxmlschema;

    # we assume that the schema files are in the same dir as Biber.pm:
    (undef, my $biber_path, undef) = File::Spec->splitpath( $INC{"Biber.pm"} );
    my $bcf_rng = File::Spec->catfile($biber_path, 'Biber', 'bcf.rng');

    if (-f $bcf_rng) {
      $CFxmlschema = XML::LibXML::RelaxNG->new( location => $bcf_rng )
    } else {
      $logger->warn("Cannot find XML::LibXML::RelaxNG schema. Skipping validation : $!");
      $self->{warnings}++;
    }

    # Parse file
    my $CFxp = $CFxmlparser->parse_file("$ctrl_file");

    # XPath context
    my $CFxpc = XML::LibXML::XPathContext->new($CFxp);
    $CFxpc->registerNs('bcf', 'https://sourceforge.net/projects/biblatex');

    # Validate against schema. Dies if it fails.
    if ($CFxmlschema) {
      eval { $CFxmlschema->validate($CFxp) };
      if (ref($@)) {
        $logger->debug( $@->dump() );
        $logger->logcroak("BibLaTeX control file \"$ctrl_file\" FAILED TO VALIDATE\n$@");
      }
      elsif ($@) {
        $logger->logcroak("BibLaTeX control file \"$ctrl_file\" FAILED TO VALIDATE\n$@");
      }
      else {
        $logger->info("BibLaTeX control file \"$ctrl_file\" validates");
      }
    }

  }

  my $ctrl = new IO::File "<$ctrl_file"
    or $logger->logcroak("Cannot open $ctrl_file: $!");

  $logger->info("Reading $ctrl_file");

  # Read control file
  require XML::LibXML::Simple;
  my $bcfxml = XML::LibXML::Simple::XMLin($ctrl,
                                          'ForceContent' => 1,
                                          'ForceArray' => [
                                                           qr/\Acitekey\z/,
                                                           qr/\Aoption\z/,
                                                           qr/\Aoptions\z/,
                                                           qr/\Avalue\z/,
                                                           qr/\Asorting\z/,
                                                           qr/\Asortitem\z/,
                                                           qr/\Abibdata\z/,
                                                           qr/\Adatasource\z/,
                                                           qr/\Asection\z/,
                                                           qr/\Asort\z/,
                                                          ],
                                          'NsStrip' => 1,
                                          'KeyAttr' => []);

  my $controlversion = $bcfxml->{version};
  Biber::Config->setblxoption('controlversion', $controlversion);
  $logger->warn("Warning: You are using biblatex version $controlversion :
biber is more likely to work with version $BIBLATEX_VERSION.")
    unless substr($controlversion, 0, 3) eq $BIBLATEX_VERSION;

  # Look at control file and populate our main data structure with its information

  # OPTIONS
  foreach my $bcfopts (@{$bcfxml->{options}}) {

    # Biber options
    if (lc($bcfopts->{component}) eq 'biber') {

      # Global options
      if (lc($bcfopts->{type}) eq 'global') {
        foreach my $bcfopt (@{$bcfopts->{option}}) {
          unless (Biber::Config->getcmdlineoption($bcfopt->{key})) { # already set on cmd line
            if (lc($bcfopt->{type}) eq 'singlevalued') {
              Biber::Config->setoption($bcfopt->{key}{content}, $bcfopt->{value}[0]{content});
            } elsif (lc($bcfopt->{type}) eq 'multivalued') {
              Biber::Config->setoption($bcfopt->{key}{content},
                [ map {$_->{content}} sort {$a->{order} <=> $b->{order}} @{$bcfopt->{value}} ]);
            }
          }
        }
      }
    }

    # BibLaTeX options
    if (lc($bcfopts->{component}) eq 'biblatex') {

      # Global options
      if (lc($bcfopts->{type}) eq 'global') {
        foreach my $bcfopt (@{$bcfopts->{option}}) {
          if (lc($bcfopt->{type}) eq 'singlevalued') {
            Biber::Config->setblxoption($bcfopt->{key}{content}, $bcfopt->{value}[0]{content});
          } elsif (lc($bcfopt->{type}) eq 'multivalued') {
            Biber::Config->setblxoption($bcfopt->{key}{content},
              [ map {$_->{content}} sort {$a->{order} <=> $b->{order}} @{$bcfopt->{value}} ]);
          }
        }
      }

      # Entrytype options
      else {
        my $entrytype = $bcfopts->{type};
        foreach my $bcfopt (@{$bcfopts->{option}}) {
          if (lc($bcfopt->{type}) eq 'singlevalued') {
            Biber::Config->setblxoption($bcfopt->{key}{content}, $bcfopt->{value}[0]{content}, 'PER_TYPE', $entrytype);
          } elsif (lc($bcfopt->{type}) eq 'multivalued') {
            Biber::Config->setblxoption($bcfopt->{key}{content},
              [ map {$_->{content}} sort {$a->{order} <=> $b->{order}} @{$bcfopt->{value}} ],
              'PER_TYPE',
              $entrytype);
          }
        }
      }
    }
  }

  # SORTING schemes
  foreach my $sortschemes (@{$bcfxml->{sorting}}) {
    my $sorting_label = [];
    my $sorting_final = [];
    foreach my $sort (sort {$a->{order} <=> $b->{order}} @{$sortschemes->{sort}}) {
      my $sortingitems_label;
      my $sortingitems_final;

      # Determine which sorting pass(es) to include the item in
      my $whichpass = ($sort->{pass} or 'both');

      # Generate sorting pass structures
      foreach my $sortitem (sort {$a->{order} <=> $b->{order}} @{$sort->{sortitem}}) {
        my $sortitemattributes = {};
        if (defined($sortitem->{final})) { # Found a sorting short-circuit marker
          $sortitemattributes->{final} = 1;
        }
        if (defined($sortitem->{substring_side})) { # Found sorting substring side attribute
          $sortitemattributes->{substring_side} = $sortitem->{substring_side};
        }
        if (defined($sortitem->{substring_width})) { # Found sorting substring length attribute
          $sortitemattributes->{substring_width} = $sortitem->{substring_width};
        }
        if (defined($sortitem->{pad_width})) { # Found sorting pad length attribute
          $sortitemattributes->{pad_width} = $sortitem->{pad_width};
        }
        if (defined($sortitem->{pad_char})) { # Found sorting pad char attribute
          $sortitemattributes->{pad_char} = $sortitem->{pad_char};
        }
        if (defined($sortitem->{pad_side})) { # Found sorting pad side attribute
          $sortitemattributes->{pad_side} = $sortitem->{pad_side};
        }
        if (defined($sortitem->{sort_direction})) { # Found sorting direction attribute
          $sortitemattributes->{sort_direction} = $sortitem->{sort_direction};
        }

        # No pass specified, sortitem is included in both sort passes
        # Note that we're cloning the sortitemattributes object so as not to have pointers
        # from one structure to the other
        if (lc($whichpass) eq 'both') {
          push @{$sortingitems_label}, {$sortitem->{content} => $sortitemattributes};
          push @{$sortingitems_final}, {$sortitem->{content} => dclone($sortitemattributes)};
        }

        # "label" specified, sortitem is included only on "label" sort pass
        elsif (lc($whichpass) eq 'label') {
          push @{$sortingitems_label}, {$sortitem->{content} => $sortitemattributes};
        }

        # "final" specified, sortitem is included only on "final" sort pass
        elsif (lc($whichpass) eq 'final') {
          push @{$sortingitems_final}, {$sortitem->{content} => $sortitemattributes};
        }
      }

      # Only push a sortitem if defined. If the item has a conditional "pass"
      # attribute, it may be ommitted in which case we don't want an empty array ref
      # pushing
      push @{$sorting_label}, $sortingitems_label if defined($sortingitems_label);
      push @{$sorting_final}, $sortingitems_final if defined($sortingitems_final);
    }
    if (lc($sortschemes->{type}) eq 'global') {
      Biber::Config->setblxoption('sorting_label', $sorting_label);
      Biber::Config->setblxoption('sorting_final', $sorting_final);
    }
    else {
      Biber::Config->setblxoption('sorting_label', $sorting_label, 'PER_TYPE', $sortschemes->{type});
      Biber::Config->setblxoption('sorting_final', $sorting_final, 'PER_TYPE', $sortschemes->{type});
    }
  }

  # SECTIONS
  # This is also where we set data files as these are associated with a bib section

  # Datafiles
  my %bibdatafiles = ();
  foreach my $data (@{$bcfxml->{bibdata}}) {
    foreach my $datasource (@{$data->{datasource}}) {
      if ($datasource->{type} eq 'file') {
        push @{$bibdatafiles{$data->{section}[0]}}, $datasource->{content};
      }
    }
  }

  unless (%bibdatafiles or Biber::Config->getoption('bibdata')) {
    $logger->logcroak("No data files on command line or provided in the file '$ctrl_file'! Exiting")
  }

  my $key_flag = 0;
  my $bib_sections = new Biber::Sections;

SECTION: foreach my $section (@{$bcfxml->{section}}) {
    my $bib_section;
    # Can be multiple section 0 entries and so re-use that section object if it exists
    if (my $existing_section = $bib_sections->get_section($section->{number})) {
      $bib_section = $existing_section;
    }
    else {
      $bib_section = new Biber::Section('number' => $section->{number});
    }

    # Set the data files for the section
    $bib_section->set_datafiles($bibdatafiles{$section->{number}});

    # Stop reading citekeys if we encounter "*" as a citation as this means
    # "all keys"
    my @keys = ();
    foreach my $keyc (@{$section->{citekey}}) {
      my $key = $keyc->{content};
      if ($key eq '*') {
        Biber::Config->setoption('allentries', 1);
        $logger->info("Processing all citekeys");
        $bib_sections->add_section($bib_section);
        last SECTION;
      }
      elsif (not Biber::Config->get_seenkey($key)) {
        push @keys, decode_utf8($key);
        $key_flag = 1; # There is at least one key, used for error reporting below
        Biber::Config->incr_seenkey($key);
      }
      elsif (Biber::Config->get_keycase($key) ne $key) {
        $logger->warn("Case mismatch error between cite keys $key and " . Biber::Config->get_keycase($key));
        $logger->warn("I'm skipping whatever remains of this command");
        $self->{warnings}++;
        next;
      }
    }
    # Die if there are no citations
    unless (Biber::Config->getoption('allentries') or $key_flag) {
      $logger->logcroak("The file '$ctrl_file' does not contain any citations!")
    }
    # Report on number of citations found
    $logger->info("Found ", $#keys+1 , " citekeys in bib section " . $section->{number})
      unless Biber::Config->getoption('allentries') ;

    if (Biber::Config->getoption('debug')) {
      my @debug_keys = sort @keys;
      unless (Biber::Config->getoption('allentries')) {
        $logger->debug("The citekeys for section " . $section->{number} . " are:\n", "@debug_keys", "\n");
      }
    }
    $bib_section->add_citekeys(@keys);
    $bib_sections->add_section($bib_section);
  }

  # --bibdata was passed on command-line
  # Add these data files to section 0
  if (Biber::Config->getoption('bibdata')) {
    $bib_sections->get_section(0)->set_datafiles([ split /,/, @{ Biber::Config->getoption('bibdata') } ]);
  }

  # Add the Biber::Sections object to the Biber object
  $self->{sections} = $bib_sections;
  return;
}

#=====================================================
# Parse BIB file
#=====================================================

=head2 parse_bibtex

    This is a wrapper method to parse a bibtex database. If available it will
    pass the job to Text::BibTeX via Biber::BibTeX, otherwise it relies on a
    slower pure Perl parser implemented in Biber::BibTeX::PRD.

=cut

sub parse_bibtex {
  my ($self, $filename) = @_;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);

  $logger->info("Processing bibtex file '$filename' for section $secnum");

  my @localkeys = ();

  my $ufilename = "$filename.utf8";

  if ( not Biber::Config->getoption('unicodebib') and
    Biber::Config->getoption('unicodebbl') ) {
    require LaTeX::Decode;
    require File::Slurp;
    my $ubib = IO::File->new( $ufilename, ">:utf8" );

    # $ubib->binmode(':utf8');

    my $mode = "";

#        if ( Biber::Config->getoption('bibencoding') ) {
#            $mode = ':encoding(' . Biber::Config->getoption('bibencoding') . ')';
#        } else {
#            $mode = "";
#        };

    my $infile = IO::File->new( $filename, "<$mode" );

    my $buf    = File::Slurp::read_file($infile)
      or $logger->logcroak("Can't read $filename");

    if ( Biber::Config->getoption('bibencoding') ) {
      $buf = decode(Biber::Config->getoption('bibencoding'), $buf)
    }

    print $ubib LaTeX::Decode::latex_decode($buf)
      or $logger->logcroak("Can't write to $ufilename : $!");
    $ubib->close or $logger->logcroak("Can't close filehandle to $ufilename: $!");

    $filename  = $ufilename;

    Biber::Config->setoption('unicodebib', 1);
  }

  unless ( eval "require Text::BibTeX; 1" ) {
    Biber::Config->setoption('useprd', 1);
  }

  unless ( Biber::Config->getoption('useprd') ) {

    require Biber::BibTeX;
    push @ISA, 'Biber::BibTeX';

    @localkeys = $self->_text_bibtex_parse($filename);
  }
  else {

    require Biber::BibTeX::PRD;
    push @ISA, 'Biber::BibTeX::PRD';

    $logger->info("Using a Parse::RecDescent parser...");

    # we only add this warning if the bib file is larger than 20KB
    if (-s $filename > 20000 ) {
      $logger->warn("Note that it can be very slow with large bib files!\n",
        "You are advised to install Text::BibTeX for faster processing!");
      $self->{warnings}++;
    };

    @localkeys = $self->_bibtex_prd_parse($filename);
  }

  unlink $ufilename if -f $ufilename;

  if (Biber::Config->getoption('allentries')) {
    map { Biber::Config->incr_seenkey($_) } @localkeys
  }

  my $bibentries = $section->bib;

# if allentries, push all bibdata keys into citekeys (if they are not already there)
# Can't just make citekeys = bibdata keys as this loses information about citekeys
# that are missing data entries.
  if (Biber::Config->getoption('allentries')) {
    foreach my $bibkey ($bibentries->sorted_keys) {
      $section->add_citekeys($bibkey);
    }
  }

  return;

}

=head2 parse_biblatexml

    $biber->parse_biblatexml('data.xml');

    Parse a database in the BibLaTeXML format with Biber::BibLaTeXML (via
    XML::LibXML). If the suffix is dbxml, then the database is assumed to
    be stored in a Berkeley DBXML container and will be queried through the
    Sleepycat::DbXml interface.

=cut

sub parse_biblatexml {
  my ($self, $xml) = @_;
  require Biber::BibLaTeXML;
  push @ISA, 'Biber::BibLaTeXML';
  $self->_parse_biblatexml($xml);
}

=head2 process_missing

   Check for missing citation keys

=cut

sub process_missing {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bib;
  $logger->debug("Checking for missing citekeys in section $secnum");
  foreach my $citekey ($section->get_citekeys) {
    unless ( $bibentries->entry_exists($citekey) ) {
      $logger->warn("I didn't find a database entry for '$citekey' (section $secnum)");
      $self->{warnings}++;
      $section->del_citekey($citekey);
      next;
    }
  }
}

=head2 process_sets_and_crossrefs

    $biber->process_sets_and_crossrefs

    This does three things:
    1. Ensures that all citekeys that are within entry sets will be output in the bbl.
    2. Ensures proper inheritance of data from cross-references.
    3. Ensures that crossrefs that are directly cited or cross-referenced
       at least $mincrossrefs times are included in the bibliography.

=cut

sub process_sets_and_crossrefs {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  $logger->debug("Processing entry sets and crossrefs for section $secnum");
  foreach my $citekey ($section->get_citekeys) {
    my $be = $section->bibentry($citekey);
    if (lc($be->get_field('entrytype')) eq 'set') {
      my @inset_keys = split /\s*,\s*/, $be->get_field('entryset');
      foreach my $inset_key (@inset_keys) {
        $logger->debug("  Adding inset entry '$inset_key' to the citekeys (section $secnum)");
        $section->add_citekeys($inset_key);
      }
    }
    if ($be->get_field('crossref')) {
      my $crossrefkey = $be->get_field('crossref');
      if ($section->has_citekey($crossrefkey)) {
        Biber::Config->add_cited_crossref($crossrefkey);
      }
      my $parent = $section->bibentry($crossrefkey);
      $logger->debug("  Entry $citekey inheriting fields from parent $crossrefkey");
      $be->inherit_from($parent);
    }
  }
  # We make sure that crossrefs that are directly cited or cross-referenced
  # at least $mincrossrefs times are included in the bibliography.
  # All crossrefs that are kept in "crossrefkeys" will be skipped
  # when writing the bbl output.
  foreach my $k ( @{Biber::Config->get_crossrefkeys} ) {
    if ( $section->has_citekey($k) or
      Biber::Config->get_crossrefkey($k) >= Biber::Config->getoption('mincrossrefs') ) {
      $logger->debug("Removing unneeded crossrefkey $k");
      Biber::Config->del_crossrefkey($k);
    }
  }
}

=head2 postprocess

    Various postprocessing operations, mostly to generate special fields for
    biblatex. This method is automatically called by C<prepare>.
    Here we parse names, generate the "namehash" and the strings for
    "labelname", "labelyear", "labelalpha", "sortstrings", etc.

=cut

sub postprocess {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bib;
  foreach my $citekey ( $section->get_citekeys ) {
    $logger->debug("Postprocessing entry '$citekey' from section $secnum");

    # Postprocess dates
    $self->postprocess_dates($citekey);

    # post process "set" entries:
    $self->postprocess_sets($citekey);

    # generate labelname name
    $self->postprocess_labelname($citekey);

    # generate labelyear name
    $self->postprocess_labelyear($citekey);

    # generate namehash,fullhash
    $self->postprocess_hashes($citekey);

    # generate labelalpha information
    $self->postprocess_labelalpha($citekey);

    # track shorthands
    $self->postprocess_shorthands($citekey);

    # Misc things to do as we process keys
    $self->postprocess_misc($citekey);

    # first-pass sorting to generate basic labels
    $self->postprocess_sorting_firstpass($citekey);
  }

  $logger->debug("Finished postprocessing entries in section $secnum");

  return;
}

=head2 postprocess_dates

    Here we do some sanity checking on date fields and then parse the
    *DATE fields into their components, collecting any warnings to put
    into the .bbl later

    Quick check on YEAR and MONTH fields which are the only date related
    components which can be directly set and therefore don't go through
    the date parsing below

=cut

sub postprocess_dates {
  my $self = shift;
  my $citekey = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bib;
  my $be = $bibentries->entry($citekey);

  # Both DATE and YEAR specified
  if ($be->get_field('date') and $be->get_field('year')) {
    $logger->warn("Field conflict - both 'date' and 'year' used - ignoring field 'year' in '$citekey'");
    $self->{warnings}++;
    $be->add_warning("Field conflict - both 'date' and 'year' used - ignoring field 'year'");
    $be->del_field('year');
  }

  # Both DATE and MONTH specified
  if ($be->get_field('date') and $be->get_field('month')) {
    $logger->warn("Field conflict - both 'date' and 'month' used - ignoring field 'month' in '$citekey'");
    $self->{warnings}++;
    $be->add_warning("Field conflict - both 'date' and 'month' used - ignoring field 'month'");
    $be->del_field('month');
  }

  # MONTH must be an integer - YEAR doesn't have to be to allow for things like
  # "in press" which sometimes need an extrayear disambiguator (in APA styles for example)
  if ($be->get_field('month') and $be->get_field('month') !~ /\A\d+\z/xms) {
    $logger->warn("Invalid format of field 'month' - ignoring field in entry '$citekey'");
    $self->{warnings}++;
    $be->add_warning("Invalid format of field 'month' - ignoring field");
    $be->del_field('month');
  }

  # Generate date components from *DATE fields
  foreach my $datetype ('', 'orig', 'event', 'url') {
    if ($be->get_field($datetype . 'date')) {
      my $date_re = qr|(\d{4})(?:-(\d{2}))?(?:-(\d{2}))?|xms;
      if ($be->get_field($datetype . 'date') =~ m|\A$date_re(/)?(?:$date_re)?\z|xms) {
        $be->set_field($datetype . 'year', $1) if $1;
        $be->set_field($datetype . 'month', $2) if $2;
        $be->set_field($datetype . 'day', $3) if $3;
        $be->set_field($datetype . 'endmonth', $6) if $6;
        $be->set_field($datetype . 'endday', $7) if $7;
        if ($4 and $5) {        # normal range
          $be->set_field($datetype . 'endyear', $5);
        } elsif ($4 and not $5) { # open ended range - endyear is defined but empty
          $be->set_field($datetype . 'endyear', '');
        }
      } else {
        $logger->warn("Invalid format of field '" . $datetype . 'date' . "' - ignoring field in entry '$citekey'");
        $self->{warnings}++;
        $be->add_warning("Invalid format of field '" . $datetype . 'date' . "' - ignoring field");
        $be->del_field($datetype . 'date');
      }
    }
  }

  # Now more carefully check the individual date components
  my $opt_dm = qr/(?:event|orig|url)?(?:end)?/xms;
  foreach my $dcf (@DATECOMPONENTFIELDS) {
    my $bad_format = '';
    if ($be->get_field($dcf)) {

      # months must be in right range
      if ($dcf =~ /\A$opt_dm month\z/xms) {
        unless ($be->get_field($dcf) >= 1 and $be->get_field($dcf) <= 12) {
          $bad_format = 1;
        }
      }

      # days must be in right range
      if ($dcf =~ /\A$opt_dm day\z/xms) {
        unless ($be->get_field($dcf) >= 1 and $be->get_field($dcf) <= 31) {
          $bad_format = 1;
        }
      }
      if ($bad_format) {
        $logger->warn("Value out bounds for field/date component '$dcf' - ignoring in entry '$citekey'");
        $self->{warnings}++;
        $be->add_warning("Value out of bounds for field/date component '$dcf' - ignoring");
        $be->del_field($dcf);
      }
    }
  }
}


=head2 postprocess_sets

    Postprocess set entries

    Checks for common set errors and enforces 'dataonly' for set members

=cut

sub postprocess_sets {
  my $self = shift;
  my $citekey = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bib;
  my $be = $bibentries->entry($citekey);
  if ( $be->get_field('entrytype') eq 'set' ) {
    my @entrysetkeys = split /\s*,\s*/, $be->get_field('entryset');

    # Enforce Biber parts of virtual "dataonly" for set members
    foreach my $member (@entrysetkeys) {
      Biber::Config->setblxoption('skiplab', 1, 'PER_ENTRY', $member);
      Biber::Config->setblxoption('skiplos', 1, 'PER_ENTRY', $member);
    }

    unless (@entrysetkeys) {
      $logger->warn("No entryset found for entry $citekey of type 'set'");
      $self->{warnings}++;
    }
    if ( $be->get_field('crossref')
      and ( $be->get_field('crossref') ne $entrysetkeys[0] ) ) {

      $logger->warn( "Problem with entry $citekey :\n"
          . "\tcrossref ("
          . $be->get_field('crossref')
          . ") should be identical to the first element of the entryset"
        );
      $self->{warnings}++;
      $be->set_field('crossref', $entrysetkeys[0]);

    }
    elsif ( not $be->get_field('crossref') ) {
      $logger->warn("Adding missing field 'crossref' to entry $citekey");
      $self->{warnings}++;
      $be->set_field('crossref', $entrysetkeys[0]);
    }
  }
}

=head2 postprocess_labelname

    Generate labelname information. Fields set are:

    * labelnamename - the name of the labelname field to use
    * labelnamenamefullhash - the name of the labelname field to use for
                              fulhash generation.

    We can retreive the actual labelname value later with:

    $entry->get_field($entry->get_field('labelnamename))

    It's neat this way as we often need to know what the labelname field is
    as well as it's actual string value

=cut

sub postprocess_labelname {
  my $self = shift;
  my $citekey = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bib;
  my $be = $bibentries->entry($citekey);
  my $bee = $be->get_field('entrytype');
  my $lnamescheme = Biber::Config->getblxoption('labelname', $bee);

  # First we set the normal labelname name
  foreach my $ln ( @{$lnamescheme} ) {
    my $lnameopt;
    if ( $ln =~ /\Ashort(.+)\z/ ) {
      $lnameopt = $1;
    } else {
      $lnameopt = $ln;
    }
    if ($be->get_field($ln) and
      Biber::Config->getblxoption("use$lnameopt", $bee, $citekey) ) {
      $be->set_field('labelnamename', $ln);
      last;
    }
  }

  # Then we loop again to set the labelname name for the fullhash generation code
  # This is because fullhash generation ignores SHORT* fields (section 4.2.4.1, BibLaTeX
  # manual)
  foreach my $ln ( @{$lnamescheme} ) {
    if ( $ln =~ /\Ashort(.+)\z/ ) {
      next;
    }
    if ($be->get_field($ln) and
      Biber::Config->getblxoption("use$ln", $bee, $citekey ) ) {
      $be->set_field('labelnamenamefullhash', $ln);
      last;
    }
  }

  # Generate the actual labelname
  if (is_def_and_notnull($be->get_field('labelnamename'))) {
    $be->set_field('labelname', $be->get_field($be->get_field('labelnamename')));
  }

  unless ( $be->get_field('labelnamename') ) {
    $logger->debug("Could not determine the labelname of entry $citekey");
  }
}

=head2 postprocess_labelyear

    Generate labelyear
    Here, "labelyearname" is the name of the labelyear field
    and "labelyear" is the actual copy of the relevant field

=cut

sub postprocess_labelyear {
  my $self = shift;
  my $citekey = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bib;
  my $be = $bibentries->entry($citekey);
  my $bee = $be->get_field('entrytype');
  my $lyearscheme = Biber::Config->getblxoption('labelyear', $be->get_field('entrytype'));

  if ($lyearscheme) {
    if (Biber::Config->getblxoption('skiplab', $bee, $citekey)) {
      return;
    }
    # make sure we gave the correct data type:
    $logger->logcroak("Invalid value for option labelyear: $lyearscheme\n")
      unless ref $lyearscheme eq 'ARRAY';
    foreach my $ly ( @{$lyearscheme} ) {
      if ($be->get_field($ly)) {
        $be->set_field('labelyearname', $ly);
        last;
      }
    }

    # Construct labelyear
    # Might not have been set due to skiplab/dataonly
    if (my $yf = $be->get_field('labelyearname')) {
      $be->set_field('labelyear', $be->get_field($yf));

      # ignore endyear if it's the same as year
      my ($ytype) = $yf =~ /\A(.*)year\z/xms;
      if (is_def_and_notnull($be->get_field($ytype . 'endyear'))
        and ($be->get_field($yf) ne $be->get_field($ytype . 'endyear'))) {
        $be->set_field('labelyear',
          $be->get_field('labelyear') . '\bibdatedash ' . $be->get_field($ytype . 'endyear'));
      }
    }
    else {
      $logger->debug("Could not determine the labelyearname of entry $citekey");
    }
  }
}

=head2 postprocess_hashes

    Generate namehash and fullhash

=cut

sub postprocess_hashes {
  my $self = shift;
  my $citekey = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bib;
  my $be = $bibentries->entry($citekey);
  my $bee = $be->get_field('entrytype');
  my $namehash = ''; # biblatex namehash field (manual, section 4.2.4.1)
  my $fullhash = ''; # biblatex fullhash field (manual, section 4.2.4.1)
  my $nameid   = '';

  # namehash is generated from the labelname
  if (my $lname = $be->get_field('labelnamename')) {
    if ($be->get_field($lname)) {
      $namehash .= $self->_getnamehash($citekey, $be->get_field($lname));
      $nameid .= makenameid($be->get_field($lname));
    }
  }
  # fullhash is generated from the labelname but ignores SHORT* fields and
  # maxnames/minnames settings
  if (my $lnamefh = $be->get_field('labelnamenamefullhash')) {
    if ($be->get_field($lnamefh)) {
      $fullhash .= $self->_getfullhash($citekey, $be->get_field($lnamefh));
    }
  }

  # After the initial generation of namehash and fullhash, we have to append
  # a suffix as they must be unique. It is possible that different entries have
  # the same hashes at this stage. For example:

  # AUTHOR = {Fred Grimble and Bill Bullter} = "FGBB"
  # AUTHOR = {Frank Garby and Brian Blunkley} = "FGBB"

  my $hashsuffix = 1;

  # First, check to see if we've already seen this exact name before
  if (Biber::Config->get_namehashcount($namehash, $nameid)) {
    # If we have, our suffix is already known
    $hashsuffix = Biber::Config->get_namehashcount($namehash, $nameid);
  }
  # Otherwise, if the namehash already exists, we'll make a new entry with a new suffix
  elsif (Biber::Config->namehashexists($namehash)) {
    # Count the suffixes already defined ...
    my $count = Biber::Config->get_numofnamehashes($namehash);
    # ... add one to the number ...
    $hashsuffix = $count + 1;
    # ... and define a new suffix for that name
    Biber::Config->set_namehashcount($namehash, $nameid, $hashsuffix);
  }
  # No entry for the namehash at all so make a new one, a new name and suffix
  else {
    Biber::Config->del_namehash($namehash);
    Biber::Config->set_namehashcount($namehash, $nameid, 1);
  }

  # Now append the suffices, making the hashes unique
  $namehash .= $hashsuffix;
  $fullhash .= $hashsuffix;

  # Set the hashes
  $be->set_field('namehash', $namehash);
  $be->set_field('fullhash', $fullhash);

  Biber::Config->incr_seennamehash($fullhash);
}


=head2 postprocess_labelalpha

    Generate the labelalpha and also the variant for sorting

=cut

sub postprocess_labelalpha {
  my $self = shift;
  my $citekey = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bib;
  my $be = $bibentries->entry($citekey);
  my $bee = $be->get_field('entrytype');
  # Don't add a label if skiplab is set for entry
  if (Biber::Config->getblxoption('skiplab', $bee, $citekey)) {
    return;
  }
  if ( Biber::Config->getblxoption('labelalpha', $be->get_field('entrytype')) ) {
    my $label;
    my $sortlabel;

    if ( $be->get_field('shorthand') ) {
      $sortlabel = $label = $be->get_field('shorthand');
    } else {
      if ( $be->get_field('label') ) {
        $sortlabel = $label = $be->get_field('label');
      } elsif ( $be->get_field('labelnamename') and $be->get_field($be->get_field('labelnamename'))) {
        ( $label, $sortlabel ) =
          @{ $self->_getlabel( $citekey, $be->get_field('labelnamename') ) };
      } else {
        $sortlabel = $label = '';
      }
      if ( my $year = $be->get_field('year') ) {
        my $yr;
        # Make "in press" years look nice in alpha styles
        if ($year =~ m/\A\s*in\s*press\s*\z/ixms) {
          $yr = 'ip';
        }
        # Normal year
        else {
          $yr = substr $year, 2, 2;
        }
        $label     .= $yr;
        $sortlabel .= $yr;
      }
    }
    $be->set_field('labelalpha', $label);
    $be->set_field('sortlabelalpha', $sortlabel);
  }
}

=head2 postprocess_shorthands

    Track shorthands

=cut

sub postprocess_shorthands {
  my $self = shift;
  my $citekey = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bib;
  my $be = $bibentries->entry($citekey);
  my $bee = $be->get_field('entrytype');
  if ( my $sh = $be->get_field('shorthand') ) {
    $section->add_shorthand($bee, $citekey);
  }
}

=head2 postprocess_misc

    Deal with some misc things

=cut

sub postprocess_misc {
  my $self = shift;
  my $citekey = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bib;
  my $be = $bibentries->entry($citekey);
  # Deal with patent entry defaults
  if ( ( $be->get_field('entrytype') eq 'patent' ) and ( not $be->get_field('type') ) ) {
    $be->set_field('type', 'patent');
  }
}

=head2 postprocess_sorting_firstpass

    First pass of sorting information generation

=cut

sub postprocess_sorting_firstpass {
  my $self = shift;
  my $citekey = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bib;
  my $be = $bibentries->entry($citekey);
  $self->_generatesortstring( $citekey, Biber::Config->getblxoption('sorting_label', $be->get_field('entrytype')));
}


=head2 generate_final_sortinfo

    Generate final sort information

=cut

sub generate_final_sortinfo {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bib;
  foreach my $citekey ($section->get_citekeys) {
    my $be = $bibentries->entry($citekey);
    $self->_generatesortstring($citekey, Biber::Config->getblxoption('sorting_final', $be->get_field('entrytype')));
  }
  return;
}

=head2 uniqueness

    Generate the uniqueness information needed when creating .bbl

=cut


sub uniqueness {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bib;
  # Generate uniqueness information according to this algorithm:
  # 1. Generate uniquename if uniquename option is set
  # 2. if (uniquelist has never run before OR step 1 changed any uniquename values) {
  #      goto step 3
  #    } else { goto step 5 }
  # 3. Completely regenerate uniquelist if uniquelist option is set
  # 4. if (step 3 changed any uniquelist values) {
  #      goto step 1
  #    } else { goto step 5 }
  # 5. Run extrayear generation if requested based on data as it stands after step 4
  # 6. Run singletitle generation if requested based on data as it stands after step 4

  # Set a flag for first uniquelist pass. This is a special case as we always want to run
  # at least one uniquelist pass if requested, regardless of unul_done global flag.
  my $first_ul_pass = 1;

  # Generate uniquename information, if requested
  while ('true') {
    unless (Biber::Config->get_unul_done) {
      Biber::Config->set_unul_changed(0); # reset state for global unul changed flag
      $self->create_uniquename_info;
      $self->generate_uniquename;
    }
    else {
      last; # uniquename/uniquelist disambiguation is finished as nothing changed
    }
    # Generate uniquelist information, if requested
    # Always run uniquelist at least once, if requested
    if ($first_ul_pass or not Biber::Config->get_unul_done) {
      Biber::Config->set_unul_changed(0); # reset state for global unul changed flag
      $first_ul_pass = 0; # Ignore special case when uniquelist has run once
      $self->create_uniquelist_info;
      $self->generate_uniquelist;
    }
    else {
      last; # uniquename/uniquelist disambiguation is finished as nothing changed
    }
  }
  # Generate singltitle/extras* information if requested
  $self->create_extras_st_info;
  # Generate extra* fields if requested
  $self->generate_extras;
  # Generate singletitle field if requested
  $self->generate_singletitle;
}


=head2 create_uniquename_info

    Gather the uniquename information as we look through the names

=cut


sub create_uniquename_info {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bib;

  # Reset uniquename information as we have to generate it again because uniquelist
  # information might have changed
  Biber::Config->reset_uniquenamecount;

  foreach my $citekey ( $section->get_citekeys ) {
    my $be = $bibentries->entry($citekey);
    my $bee = $be->get_field('entrytype');
    if (Biber::Config->getblxoption('uniquename', $bee)) {
      $logger->trace("Generating uniquename information for '$citekey'");
      my $namehash = $be->get_field('namehash');
      if (my $lname = $be->get_field('labelnamename')) {

        # First find out the maxnames setting for this namelist.
        my $ul = -1;            # Not set
        if (defined($be->get_field($lname)->get_uniquelist)) {
          $ul = $be->get_field($lname)->get_uniquelist;
        }
        my $mn = Biber::Config->getblxoption('maxnames');
        # Set the index limit beyond which we don't look for disambiguating information
        my $localmaxnames = $ul > $mn ? $ul : $mn;

        # Note that we don't determine if a name is unique here -
        # we can't, were still processing entries at this point.
        # Here we are just recording seen combinations of:
        #
        # lastnames and how many hashes were generated from them (uniquename = 0)
        # lastnames+initials how many hashes were generated from them (uniquename = 1)
        # Full name and how many hashes were generated from them (uniquename = 2)
        #
        # Anything which has more than one combination for both of these would
        # be uniquename = 2 unless even the full name doesn't disambiguate
        # and then it is left at uniquename=0

        foreach my $name (@{$be->get_field($lname)->names}) {
          # We don't want to record disambiguation information for any names
          # that are hidden by a maxnames/uniquelist limit
          unless ($name->get_index > $localmaxnames) {
            my $lastname   = $name->get_lastname;
            my $nameinitstring = $name->get_nameinitstring;
            my $namestring = $name->get_namestring;

            # Record a uniqueness information entry for the lastname showing that
            # this lastname has been seen in the name with the namehash
            Biber::Config->add_uniquenamecount($lastname, $namestring);

            # Record a uniqueness information entry for the lastname+initials showing that
            # this lastname_initials has been seen in the name with the namehash
            Biber::Config->add_uniquenamecount($nameinitstring, $namestring);

            # Record a uniqueness information entry for the fullname
            # showing that this fullname has been seen in the name with the namehash
            Biber::Config->add_uniquenamecount($namestring, $namestring);
          }
        }
      }
    }
  }
  return;
}

=head2 generate_uniquename

   Generate the per-name uniquename values using the information
   harvested by create_uniquename_info()

=cut

sub generate_uniquename {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bib;

  # Now use the information to set the actual uniquename information
  foreach my $citekey ( $section->get_citekeys ) {
    my $be = $bibentries->entry($citekey);
    my $bee = $be->get_field('entrytype');
    if (my $un = Biber::Config->getblxoption('uniquename', $bee)) {
      $logger->trace("Setting uniquename for '$citekey'");
      my $namehash = $be->get_field('namehash');

      if (my $lname = $be->get_field('labelnamename')) {
        foreach my $name (@{$be->get_field($lname)->names}) {
          my $lastname   = $name->get_lastname;
          my $nameinitstring = $name->get_nameinitstring;
          my $namestring = $name->get_namestring;

          # If there is one entry (hash) for the lastname, then it's unique
          if (Biber::Config->get_numofuniquenames($lastname) == 1) {
            $name->set_uniquename(0);
          }
          # Otherwise, if there is one entry (hash) for the lastname plus initials,
          # then it needs the initials to make it unique
          elsif (Biber::Config->get_numofuniquenames($nameinitstring) == 1) {
            $name->set_uniquename(1);
          }
          # Otherwise the name needs to be full to make it unique
          # but restrict to uniquename bibaltex option maximum

          elsif (Biber::Config->get_numofuniquenames($namestring) == 1) {
            $name->set_uniquename($un);
          }
          # Otherwise, if there is more than one entry (hash) for the full name,
          # then set to 0 since nothing will uniqueify this name and it's just
          # misleading to expand it
          elsif (Biber::Config->get_numofuniquenames($namestring) > 1) {
            $name->set_uniquename(0);
          } else {
            $name->set_uniquename(0);
          }
        }
      }
    }
  }
  return;
}

=head2 create_uniquelist_info

    Gather the uniquename information as we look through the names

=cut

sub create_uniquelist_info {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bib;

  # Reset uniquelist information as we have to generate it again because uniquename
  # information might have changed
  Biber::Config->reset_uniquelistcount;

  foreach my $citekey ( $section->get_citekeys ) {
    my $be = $bibentries->entry($citekey);
    my $bee = $be->get_field('entrytype');
    if (Biber::Config->getblxoption('uniquelist', $bee)) {
      $logger->trace("Generating uniquelist information for '$citekey'");
      my $namehash = $be->get_field('namehash');

      if (my $lname = $be->get_field('labelnamename')) {
        my $liststring = '';
        foreach my $name (@{$be->get_field($lname)->names}) {
          my $lastname   = $name->get_lastname;
          my $nameinitstring = $name->get_nameinitstring;
          my $namestring = $name->get_namestring;
          # uniquename is not set so generate uniquelist based on just lastname
          if (not defined($name->get_uniquename)) {
            $liststring .= $lastname . '|';
          }
          # uniquename indicates unique with just lastname
          elsif ($name->get_uniquename == 0) {
            $liststring .= $lastname . '|';
          }
          # uniquename indicates unique with lastname with initials
          elsif ($name->get_uniquename == 1) {
            $liststring .= $nameinitstring . '|';
          }
          # uniquename indicates unique with full name
          elsif ($name->get_uniquename == 2) {
            $liststring .= $namestring . '|';
          }
          Biber::Config->add_uniquelistcount($liststring);
        }
      }
    }
  }
  return;
}

=head2 generate_uniquelist

   Generate the per-namelist uniquelist values using the information
   harvested by create_uniquelist_info()

=cut

sub generate_uniquelist {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bib;

  foreach my $citekey ( $section->get_citekeys ) {
    my $be = $bibentries->entry($citekey);
    my $bee = $be->get_field('entrytype');
    if (Biber::Config->getblxoption('uniquelist', $bee)) {
      $logger->trace("Creating uniquelist for '$citekey'");
      my $namehash = $be->get_field('namehash');

      if (my $lname = $be->get_field('labelnamename')) {
        my $liststring = '';
        my $namefield = $be->get_field($lname);

        foreach my $name (@{$namefield->names}) {
          my $lastname   = $name->get_lastname;
          my $nameinitstring = $name->get_nameinitstring;
          my $namestring = $name->get_namestring;
          # uniquename is not set so generate uniquelist based on just lastname
          if (not defined($name->get_uniquename)) {
            $liststring .= $lastname . '|';
          }
          # uniquename indicates unique with just lastname
          elsif ($name->get_uniquename == 0) {
            $liststring .= $lastname . '|';
          }
          # uniquename indicates unique with lastname with initials
          elsif ($name->get_uniquename == 1) {
            $liststring .= $nameinitstring . '|';
          }
          # uniquename indicates unique with full name
          elsif ($name->get_uniquename == 2) {
            $liststring .= $namestring . '|';
          }
          # list is unique
          if (Biber::Config->get_uniquelistcount($liststring) == 1) {
            last;
          }
        }
        $logger->trace("Setting uniquelist for '$citekey' using '$liststring'");
        $namefield->set_uniquelist($namefield->count_uniquelist($liststring));
      }
    }
  }
  return;
}


=head2 create_extras_st_info

    Track labelname for generation of singletitle
    Track labelname/year combination for generation of extra* fields

=cut

sub create_extras_st_info {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bib;

  foreach my $citekey ( $section->get_citekeys ) {
    my $be = $bibentries->entry($citekey);
    my $bee = $be->get_field('entrytype');
    # Only generate this information if labelyear, labelalpha or singletitle is requested
    if (Biber::Config->getblxoption('labelyear', $bee) or
        Biber::Config->getblxoption('labelalpha', $bee) or
        Biber::Config->getblxoption('singletitle', $bee)) {
      $logger->trace("Creating extra*/singletitle information for '$citekey'");


      # This is all used to generate extrayear/extralpha and the rules for this are:
      # * Generate labelname/year combination for tracking extrayear
      # * If there is no labelname to use, use empty string
      # * If there is no labelyear to use, use empty string
      # * Don't increment the seennameyear count if either name or year string is empty
      #   (see code in incr_nameyear method).
      my $name_string;
      if ($be->get_field('labelnamename')) {
        $name_string = $self->_namestring($citekey, $be->get_field('labelnamename'), 1);
      } else {
        $name_string = '';
      }

      # Only generate this information if singletitle option is requested and there is a
      # labelname
      if ($name_string and
          Biber::Config->getblxoption('singletitle', $bee)) {
        Biber::Config->incr_seenname($name_string);
        $logger->trace("Setting seenname for '$citekey' to '$name_string'");
        $be->set_field('seenname', $name_string);
      }

      # Only generate this information if one of the extra* fields is requested
      if (Biber::Config->getblxoption('labelyear', $bee) or
          Biber::Config->getblxoption('labelalpha', $bee)) {
        my $year_string;
        if ($be->get_field('labelyearname')) {
          $year_string = $be->get_field($be->get_field('labelyearname'));
        } elsif ($be->get_field('year')) {
          $year_string = $be->get_field('year');
        } else {
          $year_string = '';
        }
        my $nameyear_string = $name_string . '0' . $year_string;
        Biber::Config->incr_seennameyear($name_string, $year_string);
        $logger->trace("Setting nameyear for '$citekey' to '$nameyear_string'");
        $be->set_field('nameyear', $nameyear_string);
      }
    }
  }
  return;
}

=head2 generate_extras

    Generate extrayear and extraalpha using information created by
    create_extras_info()

=cut

sub generate_extras {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bib;

  foreach my $citekey ($section->get_citekeys) {
    my $be = $bibentries->entry($citekey);
    my $bee = $be->get_field('entrytype');
    if (Biber::Config->getblxoption('labelyear', $bee) or
        Biber::Config->getblxoption('labelalpha', $bee)) {
      my $nameyear = $be->get_field('nameyear');
      # Only generate extrayear if skiplab is not set.
      # Don't forget that skiplab is implied for set members
      unless (Biber::Config->getblxoption('skiplab', $bee, $citekey)) {
        if (Biber::Config->get_seennameyear($nameyear) > 1) {
          Biber::Config->incr_seenlabelyear($nameyear);
          if (Biber::Config->getblxoption('labelyear', $bee) ) {
            $be->set_field('extrayear', Biber::Config->get_seenlabelyear($nameyear));
          }
          if (Biber::Config->getblxoption('labelalpha', $bee) ) {
            $be->set_field('extraalpha', Biber::Config->get_seenlabelyear($nameyear));
          }
        }
      }
    }
  }
  return;
}

=head2 generate_singletitle

    Generate the singletitle field, if requested. The information for generating
    this is gathered in create_extras_st_info()

=cut

sub generate_singletitle {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bib;

  foreach my $citekey ( $section->get_citekeys ) {
    my $be = $bibentries->entry($citekey);
    if (Biber::Config->getblxoption('singletitle', $be->get_field('entrytype'))) {
      $logger->trace("Generating singletitle information for '$citekey'");
      if ($be->get_field('seenname') and
          Biber::Config->get_seenname($be->get_field('seenname')) < 2 ) {
        $be->set_field('singletitle', 1);
      }
    }
  }
  return;
}


#===========================
# SORTING
#===========================

=head2 sortentries

    Sort the entries according to a certain sorting scheme.

=cut

sub sortentries {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bib;
  my @citekeys = $section->get_citekeys;

  if ( Biber::Config->getoption('fastsort') ) {
    use locale;
    if (Biber::Config->getoption('locale')) {
      my $thislocale = Biber::Config->getoption('locale');
      $logger->debug("Sorting entries with built-in sort (with locale $thislocale) ...");
      unless (setlocale( LC_ALL, $thislocale )) {
        $logger->warn("Unavailable locale $thislocale");
        $self->{warnings}++;
      }
    } else {
      $logger->debug("Sorting entries with built-in sort (with locale ", $ENV{LC_COLLATE}, ") ...");
    }
    @citekeys = sort {
      $bibentries->entry($a)->get_field('sortstring') cmp $bibentries->entry($b)->get_field('sortstring')
      } @citekeys;
  } else {
    require Unicode::Collate;
    my $opts = Biber::Config->getoption('collate_options');
    my $collopts;
    unless (ref($opts) eq "HASH") { # opts for this can come in a string from cmd line
      $collopts = eval "{ $opts }" or $logger->logcarp("Incorrect collate_options: $@");
    }
    else {
      $collopts = $opts;
    }
    my $Collator = Unicode::Collate->new( %{$collopts} )
      or $logger->logcarp("Problem with Unicode::Collate options: $@");
    my $UCAversion = $Collator->version();
    $logger->info("Sorting with Unicode::Collate (" .
		  stringify_hash($collopts) . ", UCA version: $UCAversion)");
    @citekeys = sort {
      $Collator->cmp( $bibentries->entry($a)->get_field('sortstring'),
        $bibentries->entry($b)->get_field('sortstring') )
      } @citekeys;
  }
  $section->set_citekeys([ @citekeys ]);

  return;
}

=head2 sortshorthands

    Sort the shorthands according to a certain sorting scheme.
    If sortlos = 1 (los), sort by shorthand
    If sortlos = 0 (bib), sort by bibliography order

=cut

sub sortshorthands {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);
  my $bibentries = $section->bib;
  my @shorthands = $section->get_shorthands;
  # What we sort on depends on the 'sortlos' BibLaTeX option
  my $sortlos = Biber::Config->getblxoption('sortlos') ? 'shorthand' : 'sortstring';

  if ( Biber::Config->getoption('fastsort') ) {
    if (Biber::Config->getoption('locale')) {
      my $thislocale = Biber::Config->getoption('locale');
      $logger->debug("Sorting shorthands with built-in sort (with locale $thislocale) ...");
      unless (setlocale( LC_ALL, $thislocale )) {
        $logger->warn("Unavailable locale $thislocale");
        $self->{warnings}++;
      }
    } else {
      $logger->debug("Sorting shorthands with built-in sort (with locale ", $ENV{LC_COLLATE}, ") ...");
    }
    @shorthands = sort { $bibentries->entry($a)->get_field($sortlos) cmp $bibentries->entry($b)->get_field($sortlos) } @shorthands;
  } else {
    require Unicode::Collate;
    my $opts = Biber::Config->getoption('collate_options');
    my $collopts;
    unless (ref($opts) eq "HASH") { # opts for this can come in a string from cmd line
      $collopts = eval "{ $opts }" or $logger->logcarp("Incorrect collate_options: $@");
    }
    else {
      $collopts = $opts;
    }
    my $Collator = Unicode::Collate->new( %{$collopts} )
      or $logger->logcarp("Problem with Unicode::Collate options: $@");
    my $UCAversion = $Collator->version();
    $logger->info("Sorting with Unicode::Collate (" .
		  stringify_hash($collopts) . ", UCA version: $UCAversion)");
    @shorthands = sort {
      $Collator->cmp($bibentries->entry($a)->get_field($sortlos),
        $bibentries->entry($b)->get_field($sortlos))
      } @shorthands;
  }
  $section->set_shorthands([ @shorthands ]);

  return;
}

=head2 prepare

    Do the main work.
    Process and sort all entries before writing the bbl output.

=cut

sub prepare {
  my $self = shift;
  foreach my $section (@{$self->sections->get_sections}) {
    my $secnum = $section->number;
    $logger->info("Processing bib section $secnum");
    Biber::Config->_init; # (re)initialise Config object
    $self->set_current_section($secnum); # Set the section number we are working on
    $self->process_data; # Parse data into section objects
    $self->process_missing; # Check for missing citekeys before anything else
    $self->process_sets_and_crossrefs; # Process sets and crossrefs
    $self->postprocess; # in here we generate lots of information
    $self->sortentries; # then we do a label sort pass
    $self->uniqueness; # Here we generate uniqueness information (extra*, unique* etc.)
    $self->generate_final_sortinfo; # in here we generate the final sort string
    $self->sortentries; # and then we do a final sort pass
    $self->create_output_section; # Generate and push the section output into the
                                  # output object ready for writing
  }
  $self->create_output_misc; # Generate and push the final misc bits of output
                             # into the output object ready for writing
  return;
}

=head2 process_data

    Read the data file(s) for the section and store it in the section object

=cut

sub process_data {
  my $self = shift;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);

  foreach my $datafile ($section->get_datafiles) {
    # this uses "kpsepath bib" and File::Find to find $bib in $BIBINPUTS paths:
    $datafile = bibfind($datafile);

    if ($datafile =~ /\.(?:db)?xml$/) {
      $logger->logcroak("File $datafile does not exist!") unless -f $datafile;
      ##DISABLED: $biber->parse_biblatexml( $bib )
      $logger->logcroak("Support for the BibLaTeXML format is not included in this version of Biber.\n",
                        "You can try (at your own risk) to pull the \"biblatexml\" branch of our git repo.")
    } elsif ($datafile =~ /\.bib$/) {
      $logger->logcroak("File $datafile does not exist!") unless -f $datafile;
      $self->parse_bibtex($datafile)
    } else {
      $logger->logcroak("File $datafile.bib does not exist!") unless -f "$datafile.bib";
      $self->parse_bibtex("$datafile.bib");
    }
  }
  return;
}

=head2 create_output_section

    Create the output from the sections data and push it into the
    output object. You can subclass Biber and
    override this method to output things other than .bbl

=cut

sub create_output_section {
  my $self = shift;
  my $output_obj = $self->get_output_obj;
  my $secnum = $self->get_current_section;
  my $section = $self->sections->get_section($secnum);

  my @citekeys = $section->get_citekeys;
  # We rely on the order of this array for the order of the .bbl
  # and therefore the .bib
  foreach my $k (@citekeys) {
    ## skip crossrefkeys (those that are directly cited or
    #  crossref'd >= mincrossrefs were previously removed)
    #  EXCEPT those that are also in a set
    next if ( Biber::Config->get_crossrefkey($k) and
              not Biber::Config->get_setparentkey($k) );
    my $be = $section->bibentry($k) or $logger->logcroak("Cannot find $k");
    $output_obj->set_output_entry($be, $secnum);
  }
  # Push the sorted shorthands for each section into the output object
  if ( $section->get_shorthands ) {
    $self->sortshorthands;
    $output_obj->set_los([ $section->get_shorthands ], $secnum);
  }

  return;
}

=head2 create_output_misc

    Create the output for misc bits and pieces like preamble and closing
    macro call and add to output object. You can subclass Biber and
    override this method to output things other than .bbl

=cut

sub create_output_misc {
  my $self = shift;
  my $output_obj = $self->get_output_obj;

  if ($self->{preamble}) {
    $output_obj->add_output_head("\\preamble{%\n" .
                                 join("%\n", @{$self->{preamble}}) .
                                 "%\n}\n\n");
  }

  $output_obj->add_output_tail("\\endinput\n\n");
  return;
}


=head2 _filedump and _stringdump

    Dump the biber object with Data::Dump for debugging

=cut

sub _filedump {
  my ($self, $file) = @_;
  my $fh = IO::File->new($file, '>') or croak "Can't open file $file for writing";
  print $fh Data::Dump::pp($self);
  close $fh;
  return
}

sub _stringdump {
  my $self = shift ;
  return Data::Dump::pp($self);
}

=head1 AUTHORS

Franois Charette, C<< <firmicus at gmx.net> >>
Philip Kime C<< <philip at kime.org.uk> >>

=head1 BUGS

Please report any bugs or feature requests on our sourceforge tracker at
L<https://sourceforge.net/tracker2/?func=browse&group_id=228270>.

=head1 COPYRIGHT & LICENSE

Copyright 2009-2010 Franois Charette and Philip Kime, all rights reserved.

This program is free software; you can redistribute it and/or
modify it under the terms of either:

=over 4

=item * the GNU General Public License as published by the Free
Software Foundation; either version 1, or (at your option) any
later version, or

=item * the Artistic License version 2.0.

=back

=cut

1;

# vim: set tabstop=2 shiftwidth=2 expandtab:
